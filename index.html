<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>The World in Conflict — Map Editor</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>

  <style>
    html, body, #map { height:100%; margin:0; background:#0f112f; }

    /* HUD, badges, toolbar */
    .twic-hud {
      position:absolute; left:8px; bottom:8px; z-index:1000;
      background:#ffffffd9; padding:6px 10px; border-radius:8px;
      font:12px/1.2 system-ui,sans-serif; box-shadow:0 2px 8px rgba(0,0,0,.15);
    }
    .twic-badge, .leaflet-tooltip.twic-badge {
      font:600 12px/1.2 system-ui,sans-serif; color:#111; background:#fff;
      border:1px solid #e5e7eb; border-radius:6px; padding:3px 6px;
      box-shadow:0 1px 6px rgba(0,0,0,.15);
      pointer-events:none;
    }
    .twic-toolbar {
      position:absolute; right:8px; top:8px; z-index:1000; display:flex; gap:6px;
    }
    .twic-btn {
      background:#fff; border:1px solid #e5e7eb; border-radius:8px; padding:6px 10px;
      font:12px system-ui; cursor:pointer; box-shadow:0 2px 8px rgba(0,0,0,.1);
    }
    .twic-btn.active { background:#111827; color:#fff; border-color:#111827; }

    /* Overlay tool panel */
    .twic-panel {
      position:absolute; right:8px; top:60px; z-index:1000;
      width:300px; background:#ffffffee; border:1px solid #e5e7eb; border-radius:12px;
      padding:10px; font:12px system-ui,sans-serif; box-shadow:0 8px 24px rgba(0,0,0,.15);
    }
    .twic-panel h3 { margin:0 0 8px; font-size:13px }
    .twic-row { display:flex; gap:8px; margin-bottom:8px; align-items:center }
    .twic-row label { min-width:84px }
    .twic-row input, .twic-row select {
      flex:1; padding:6px 8px; border:1px solid #e5e7eb; border-radius:8px;
    }
    .twic-tabs { align-items:stretch; }
    .twic-tab { flex:1; font-weight:600; text-align:center; }
    .twic-muted { color:#6b7280; font-size:11px; margin-top:4px }
    .twic-text {
      background:#fff; border:1px solid #e5e7eb; border-radius:6px; padding:3px 6px;
      color:#111; font:600 12px/1.2 system-ui,sans-serif; white-space:pre-wrap;
    }
  </style>
</head>
<body>

  <!-- Focusable map (so Esc/Delete work on GitHub Pages) -->
  <div id="map" tabindex="0"></div>

  <!-- HUD + measurement toolbar -->
  <div class="twic-hud" id="twicHud">X,Y: —, — | Zoom: — | 1 px = —</div>
  <div class="twic-toolbar">
    <button class="twic-btn" id="measureBtn">Measure</button>
    <button class="twic-btn" id="clearBtn">Clear</button>
  </div>

  <!-- Overlay (text + NATO icons) panel -->
  <div class="twic-panel">
    <h3>Overlay Tools</h3>

    <div class="twic-row twic-tabs">
      <button class="twic-btn twic-tab" type="button" data-panel="nato">NATO</button>
      <button class="twic-btn twic-tab" type="button" data-panel="text">Text</button>
      <button class="twic-btn twic-tab" type="button" data-panel="weaponRange">Range</button>
      <button class="twic-btn twic-tab" type="button" data-panel="maneuver">Maneuver</button>
    </div>

    <!-- Text box options -->
    <div id="textOpts">
      <div class="twic-row"><label>Text</label><input id="txtText" type="text" placeholder="Label…"/></div>
      <div class="twic-row">
        <label>Size</label><input id="txtSize" type="number" value="12" min="8" max="48"/>
        <label>Color</label><input id="txtColor" type="color" value="#111111"/>
      </div>
      <div class="twic-row">
        <label>BG</label><input id="txtBg" type="color" value="#ffffff"/>
        <label>Border</label><input id="txtBorder" type="color" value="#e5e7eb"/>
      </div>
      <div class="twic-muted">Click map to place a text box.</div>
      <div style="display:flex; justify-content:flex-end; margin-top:6px;">
        <button class="twic-btn" type="button" id="btnPlaceText">Place Text</button>
      </div>
    </div>

    <!-- Simplified NATO options -->
    <div id="natoOpts" style="display:none">
      <div class="twic-row">
        <label>Domain</label>
        <select id="natoDomain">
          <option value="A">Air</option>
          <option value="S">Surface</option>
          <option value="G">Ground</option>
          <option value="U">Subsurface</option>
        </select>
      </div>
      <div class="twic-row">
        <label>Affil.</label>
        <select id="natoAff">
          <option value="F">Friendly</option>
          <option value="H">Hostile</option>
          <option value="N">Neutral</option>
        </select>
        <label>Size</label><input id="natoSize" type="number" value="36" min="16" max="96"/>
      </div>
      <div class="twic-muted">Click map to place a NATO symbol.</div>
      <div style="display:flex; justify-content:flex-end; margin-top:6px;">
        <button class="twic-btn" type="button" id="btnPlaceNato">Place NATO Icon</button>
      </div>
    </div>

    <!-- Weapon engagement range options -->
    <div id="weaponOpts" style="display:none">
      <div class="twic-row"><label>Radius (nm)</label><input id="weaponRadius" type="number" value="180" min="18" step="18"/></div>
      <div class="twic-row">
        <label>Stroke</label><input id="weaponStroke" type="color" value="#ef4444"/>
        <label>Fill</label><input id="weaponFill" type="color" value="#ef4444"/>
      </div>
      <div class="twic-row"><label>Fill α</label><input id="weaponOpacity" type="number" value="0.15" min="0" max="1" step="0.05"/></div>
      <div class="twic-muted">Click map to place a range circle in nautical miles.</div>
      <div style="display:flex; justify-content:flex-end; margin-top:6px;">
        <button class="twic-btn" type="button" id="btnPlaceRange">Place Range</button>
      </div>
    </div>

    <!-- Maneuver line options -->
    <div id="maneuverOpts" style="display:none">
      <div class="twic-row">
        <label>Color</label><input id="maneuverColor" type="color" value="#2563eb"/>
        <label>Width</label><input id="maneuverWidth" type="number" value="3" min="1" max="12"/>
      </div>
      <div class="twic-row">
        <label>Dash</label>
        <select id="maneuverDash">
          <option value="solid">Solid</option>
          <option value="dashed" selected>Dashed</option>
          <option value="dotted">Dotted</option>
        </select>
      </div>
      <div class="twic-muted">Click start and end points to draw a line of maneuver.</div>
      <div style="display:flex; justify-content:flex-end; gap:6px; margin-top:6px; flex-wrap:wrap;">
        <button class="twic-btn" type="button" id="btnExecuteManeuver">Execute</button>
        <button class="twic-btn" type="button" id="btnPlaceManeuver">Place Maneuver</button>
      </div>
    </div>

    <!-- Share + overlay actions -->
    <div style="display:flex; gap:8px; flex-wrap:wrap;">
      <button class="twic-btn" id="btnShare" title="Encode overlays into the URL">Share link</button>
      <button class="twic-btn" id="btnDelete">Delete Selected</button>
      <button class="twic-btn" id="btnOverlayClear">Clear All</button>
    </div>
    <div class="twic-muted" style="margin-top:6px">
      Shared state: uses URL hash if present; otherwise loads <code>overlays.geojson</code> (if in repo).
    </div>
  </div>

  <!-- Scripts -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <!-- milsymbol UMD (use jsDelivr for correct MIME on Pages) -->
  <script src="https://cdn.jsdelivr.net/npm/milsymbol@3.0.3/dist/milsymbol.min.js"></script>
  <!-- LZ-String for shareable URL compression -->
  <script src="https://cdn.jsdelivr.net/npm/lz-string@1.5.0/libs/lz-string.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script>
  /* ===== Base map (PNG + XYZ tiles z=0..7) ===== */
  const MAX_ZOOM = 7;
  const TILE_URL = './tiles/{z}/{x}/{y}.png';

  const map = L.map('map', {
    crs: L.CRS.Simple,
    minZoom: 0,
    maxZoom: MAX_ZOOM,
    zoom: 0,
    center: [-56,128],
    updateWhenIdle: true,
    zoomAnimation: true,
    keyboard: true
  });
  const mapEl = map.getContainer();
  const overlayPane = map.getPanes().overlayPane;
  const markerPane = map.getPanes().markerPane;
  setTimeout(() => mapEl.focus(), 0);

  let singlePlacementActive = false;
  let singlePlacementMode = null;
  let measurementCancel = null;
  let measurementHandlePoint = null;
  let measurementActive = false;

  function updateMapCursor(){
    if(measurementActive || singlePlacementActive){
      mapEl.style.cursor = 'crosshair';
    } else {
      mapEl.style.cursor = '';
    }
  }

  L.tileLayer(TILE_URL, {
    tileSize: 256,
    minZoom: 0,
    maxZoom: MAX_ZOOM,
    noWrap: true,
    tms: false,           // you used --xyz with gdal2tiles
    detectRetina: true,
    keepBuffer: 2
  }).addTo(map);

  map.flyTo([-56,128], 2, { animate:true, duration:1.2 });

  const overlayPointerLocks = new Set();
  function updateOverlayPointerPassthrough(){
    const hasLocks = overlayPointerLocks.size > 0;
    const maneuverOnly = (overlayPointerLocks.size === 1 && overlayPointerLocks.has('maneuver'));
    const placementLock = overlayPointerLocks.has('placement');
    const weaponRangePlacement = placementLock && singlePlacementMode === 'weaponRange';
    const textPlacement = placementLock && singlePlacementMode === 'text';
    const overlayValue = hasLocks ? 'none' : '';
    const markerLocked = hasLocks && !maneuverOnly && !weaponRangePlacement && !textPlacement;
    const markerValue = markerLocked ? 'none' : '';
    if(overlayPane) overlayPane.style.pointerEvents = overlayValue;
    if(markerPane) markerPane.style.pointerEvents = markerValue;
  }
  function setOverlayPointerPassthrough(lockId, enabled){
    if(!lockId) return;
    if(enabled) overlayPointerLocks.add(lockId);
    else overlayPointerLocks.delete(lockId);
    updateOverlayPointerPassthrough();
  }

  /* ===== Coordinate HUD ===== */
  const UNITS_PER_PIXEL = 18, UNIT_NAME = 'nautical miles';
  (function addCoordinateHUD(){
    const hud = document.getElementById('twicHud');
    function render(e){
      const z = map.getZoom();
      const p = e?.latlng ?? map.getCenter();
      hud.textContent = `X,Y: ${p.lng.toFixed(0)}, ${p.lat.toFixed(0)} | Zoom: ${z} | 1 px = ${UNITS_PER_PIXEL} ${UNIT_NAME}`;
    }
    map.on('mousemove zoomend moveend', render);
    render();
  })();

  /* ===== Measurement tool ===== */

  function formatNauticalMiles(lengthNm){
    return `${lengthNm.toFixed(2)} ${UNIT_NAME}`;
  }

  function computeLineLengthNm(start, end){
    if(!start || !end) return 0;
    return Math.hypot(end.lng - start.lng, end.lat - start.lat) * UNITS_PER_PIXEL;
  }

  function midpointLatLng(start, end){
    if(!start || !end) return null;
    return L.latLng((start.lat + end.lat) / 2, (start.lng + end.lng) / 2);
  }

  function attachManeuverLengthLabel(polyline){
    if(!polyline || typeof polyline.getLatLngs !== 'function') return;
    const latlngs = polyline.getLatLngs();

    if(!Array.isArray(latlngs) || latlngs.length < 2){
      if(polyline._lengthTooltip){
        polyline.unbindTooltip();
        polyline._lengthTooltip = null;
      }
      if(polyline._lengthTooltipRemoveHandler){
        polyline.off('remove', polyline._lengthTooltipRemoveHandler);
        polyline._lengthTooltipRemoveHandler = null;
      }
      return;
    }

    if(polyline._lengthTooltipRemoveHandler){
      polyline.off('remove', polyline._lengthTooltipRemoveHandler);
      polyline._lengthTooltipRemoveHandler = null;
    }
    if(polyline._lengthTooltip){
      polyline.unbindTooltip();
      polyline._lengthTooltip = null;
    }

    const start = latlngs[0];
    const end = latlngs[latlngs.length - 1];
    const nmLength = computeLineLengthNm(start, end);
    const midpoint = midpointLatLng(start, end);
    if(!midpoint) return;

    const tooltip = L.tooltip({
      permanent: true,
      direction: 'center',
      className: 'twic-badge twic-badge--maneuver',
      offset: [0, 0],
      opacity: 1
    }).setContent(formatNauticalMiles(nmLength)).setLatLng(midpoint);

    polyline.bindTooltip(tooltip);
    polyline._lengthTooltip = tooltip;

    const removeHandler = () => {
      if(polyline._lengthTooltip){
        polyline.unbindTooltip();
        polyline._lengthTooltip = null;
      }
      if(polyline._lengthTooltipRemoveHandler){
        polyline.off('remove', polyline._lengthTooltipRemoveHandler);
        polyline._lengthTooltipRemoveHandler = null;
      }
    };

    polyline._lengthTooltipRemoveHandler = removeHandler;
    polyline.on('remove', removeHandler);
  }
  function removeManeuverHandle(polyline){
    if(!polyline) return;
    const handle = polyline._selectionHandle;
    if(handle){
      handle.off?.('click');
      if(map?.hasLayer?.(handle)) map.removeLayer(handle);
      polyline._selectionHandle = null;
    }
    if(polyline._selectionHandleRemoveHandler){
      polyline.off('remove', polyline._selectionHandleRemoveHandler);
      polyline._selectionHandleRemoveHandler = null;
    }
  }
  function syncManeuverHandle(polyline){
    if(!polyline || typeof polyline.getLatLngs !== 'function') return;
    const latlngs = polyline.getLatLngs();
    if(!Array.isArray(latlngs) || latlngs.length < 2){
      removeManeuverHandle(polyline);
      return;
    }
    const start = latlngs[0];
    const end = latlngs[latlngs.length - 1];
    const midpoint = midpointLatLng(start, end);
    if(!midpoint){
      removeManeuverHandle(polyline);
      return;
    }

    if(!polyline._selectionHandle){
      const handle = L.circleMarker(midpoint, {
        radius: 6,
        weight: 2,
        color: '#111827',
        fillColor: '#fff',
        fillOpacity: 1,
        interactive: true,
        bubblingMouseEvents: false
      }).addTo(map);
      handle.on('click', e => {
        selectLayer(polyline);
        stopLeafletEvent(e);
      });
      polyline._selectionHandle = handle;
      if(!polyline._selectionHandleRemoveHandler){
        polyline._selectionHandleRemoveHandler = () => removeManeuverHandle(polyline);
        polyline.on('remove', polyline._selectionHandleRemoveHandler);
      }
    } else {
      polyline._selectionHandle.setLatLng(midpoint);
    }
  }
  function updateManeuverPolylineArtifacts(polyline){
    attachManeuverLengthLabel(polyline);
    syncManeuverHandle(polyline);
  }
  function ensureManeuverLatLngSync(polyline){
    if(!polyline || polyline._maneuverLatLngSync) return;
    polyline._maneuverLatLngSync = true;
    ['setLatLngs','addLatLng','spliceLatLngs'].forEach(methodName => {
      const original = polyline[methodName];
      if(typeof original !== 'function') return;
      polyline[methodName] = function(...args){
        const result = original.apply(this, args);
        updateManeuverPolylineArtifacts(this);
        return result;
      };
    });
  }
  function decorateManeuverPolyline(polyline){
    if(!polyline) return;
    ensureManeuverLatLngSync(polyline);
    updateManeuverPolylineArtifacts(polyline);
  }
  (function addMeasureTool(){
    let active=false, start=null, guide=null;
    const group = L.layerGroup().addTo(map);
    const measureBtn = document.getElementById('measureBtn');
    const clearBtn   = document.getElementById('clearBtn');

    let prevInteractions = null;
    function disableMapInteractions(){
      if(prevInteractions) return;
      prevInteractions = {
        dragging: map.dragging?.enabled?.() ?? false,
        scrollWheelZoom: map.scrollWheelZoom?.enabled?.() ?? false,
        doubleClickZoom: map.doubleClickZoom?.enabled?.() ?? false,
        boxZoom: map.boxZoom?.enabled?.() ?? false,
        touchZoom: map.touchZoom?.enabled?.() ?? false,
        keyboard: map.keyboard?.enabled?.() ?? false
      };
      map.dragging?.disable?.();
      map.scrollWheelZoom?.disable?.();
      map.doubleClickZoom?.disable?.();
      map.boxZoom?.disable?.();
      map.touchZoom?.disable?.();
      map.keyboard?.disable?.();
    }
    function restoreMapInteractions(){
      if(!prevInteractions) return;
      if(prevInteractions.dragging) map.dragging?.enable?.();
      if(prevInteractions.scrollWheelZoom) map.scrollWheelZoom?.enable?.();
      if(prevInteractions.doubleClickZoom) map.doubleClickZoom?.enable?.();
      if(prevInteractions.boxZoom) map.boxZoom?.enable?.();
      if(prevInteractions.touchZoom) map.touchZoom?.enable?.();
      if(prevInteractions.keyboard) map.keyboard?.enable?.();
      prevInteractions = null;
    }
    function syncOverlayInteractivity(){
      const disable = measurementActive;
      setOverlayPointerPassthrough('measure', disable);
      if(disable) disableMapInteractions(); else restoreMapInteractions();
    }

    function handlePoint(latlng){
      if(!active) return;
      if(!start){
        start = latlng;
        guide = L.polyline([start,start], { color:'#111827', weight:2, dashArray:'5,4' }).addTo(map);
      } else {
        const end = latlng;
        L.polyline([start,end], { color:'#111827', weight:3 }).addTo(group);
        const nmLength = computeLineLengthNm(start, end);
        const mid = midpointLatLng(start, end);
        L.marker(mid, {
          icon: L.divIcon({ className:'twic-badge', html: formatNauticalMiles(nmLength), iconSize: null }),
          interactive: false
        }).addTo(group);
        cancel();
      }
    }

    measurementHandlePoint = handlePoint;

    function begin(){
      active=true; start=null; measurementActive = true; syncOverlayInteractivity();
      resetManeuverDraft();
      updateMapCursor();
      mapEl.focus();
    }
    function cancel(){
      active=false; start=null; measurementActive = false; syncOverlayInteractivity();
      if(guide){ map.removeLayer(guide); guide=null; }
      updateMapCursor();
      measureBtn?.classList.remove('active');
    }
    function clearAll(){ group.clearLayers(); cancel(); }

    map.on('click', e => { handlePoint(e.latlng); });
    map.on('mousemove', e => { if(active && guide && start) guide.setLatLngs([start, e.latlng]); });
    document.addEventListener('keydown', e => { if(e.key === 'Escape') cancel(); });

    measurementCancel = cancel;

    measureBtn.onclick = () => { measureBtn.classList.add('active'); begin(); };
    clearBtn.onclick   = () => { measureBtn.classList.remove('active'); clearAll(); };
  })();

  /* ===== Overlay: text + simplified NATO symbols (frame/fill only) ===== */
  const overlayLayer = L.layerGroup().addTo(map);
  let selected = null;
  let maneuverStart = null, maneuverStartAnchor = null, maneuverGuide = null, maneuverGuideTooltip = null;

  const overlayIndex = new Map();
  const pendingRangeAttachments = new Map();
  const pendingTextAttachments = new Map();
  const pendingManeuverAttachments = new Map();
  const anchoredTextLayers = new Set();
  const weaponRangeLayers = new Set();
  const activeMarkerAnimations = new Map();

  function generateOverlayId(kind='overlay'){
    if(window.crypto?.randomUUID) return crypto.randomUUID();
    return `${kind}-${Math.random().toString(36).slice(2,10)}${Date.now().toString(36)}`;
  }

  function ensureMarkerAttachmentHandlers(marker){
    if(marker._attachmentHandler) return;
    marker._attachmentHandler = () => {
      const latlng = marker.getLatLng();
      if(marker === maneuverStartAnchor){
        maneuverStart = latlng;
        if(maneuverGuide){
          const guideLatLngs = maneuverGuide.getLatLngs?.() || [];
          const endLatLng = guideLatLngs[guideLatLngs.length - 1] || latlng;
          maneuverGuide.setLatLngs([latlng, endLatLng]);
        }
        if(maneuverGuideTooltip){
          maneuverGuideTooltip.setLatLng(latlng);
        }
      }
      marker._attachedRanges?.forEach(range => range.setLatLng(latlng));
      marker._attachedTexts?.forEach(textLayer => syncAnchoredTextPosition(textLayer, marker));
      if(marker._attachedManeuvers instanceof Map){
        marker._attachedManeuvers.forEach((role, polyline) => {
          if(!polyline?.getLatLngs) return;
          const latlngs = polyline.getLatLngs();
          if(!Array.isArray(latlngs) || latlngs.length < 2) return;
          if(role === 'start') latlngs[0] = latlng;
          else latlngs[latlngs.length - 1] = latlng;
          polyline.setLatLngs(latlngs);
          refreshManeuverLengthLabel(polyline);
        });
      }
    };
    marker.on('drag', marker._attachmentHandler);
    marker.on('move', marker._attachmentHandler);
  }

  function ensureRangeHandle(range){
    if(!range) return null;
    if(range._selectionHandle){
      weaponRangeLayers.add(range);
      updateRangeHandlePosition(range);
      return range._selectionHandle;
    }
    const handle = L.circleMarker(range.getLatLng(), {
      radius: 4,
      color: '#111827',
      weight: 1,
      fillColor: '#ffffff',
      fillOpacity: 1,
      interactive: true
    });
    handle._parentRange = range;
    range._selectionHandle = handle;
    weaponRangeLayers.add(range);
    handle.addTo(overlayLayer);
    handle.on('click', e => {
      selectLayer(range);
      stopLeafletEvent(e);
    });
    handle.on('mousedown', stopLeafletEvent);
    handle.on('touchstart', stopLeafletEvent);
    updateRangeHandlePosition(range);
    return handle;
  }

  function updateRangeHandlePosition(range){
    if(!range?._selectionHandle) return;
    const center = range.getLatLng?.();
    if(!center) return;
    let target = null;
    if(map?.latLngToLayerPoint && map?.layerPointToLatLng){
      const centerPoint = map.latLngToLayerPoint(center);
      const radiusPx = Number.isFinite(range._radius) ? range._radius : null;
      if(radiusPx !== null){
        const handlePoint = centerPoint.add(L.point(radiusPx, 0));
        target = map.layerPointToLatLng(handlePoint);
      }
    }
    if(!target){
      const radius = range.getRadius?.();
      if(Number.isFinite(radius)) target = L.latLng(center.lat, center.lng + radius);
    }
    if(!target) target = center;
    range._selectionHandle.setLatLng(target);
  }

  function destroyRangeHandle(range){
    if(!range) return;
    weaponRangeLayers.delete(range);
    const handle = range._selectionHandle;
    if(!handle) return;
    range._selectionHandle = null;
    handle._parentRange = null;
    if(overlayLayer.hasLayer(handle)) overlayLayer.removeLayer(handle);
    handle.off('click');
    handle.off('mousedown');
    handle.off('touchstart');
  }

  function attachRangeToMarker(range, marker){
    if(!marker) return;
    const markerId = marker.options?.meta?.id;
    if(!markerId) return;
    if(!marker._attachedRanges) marker._attachedRanges = new Set();
    marker._attachedRanges.add(range);
    range._attachedTo = marker;
    range.options.meta.attachedTo = markerId;
    range.setLatLng(marker.getLatLng());
    ensureRangeHandle(range);
    updateRangeHandlePosition(range);
    ensureMarkerAttachmentHandlers(marker);
  }

  function queueRangeForMarker(range, markerId){
    if(!markerId) return;
    const list = pendingRangeAttachments.get(markerId) || [];
    list.push(range);
    pendingRangeAttachments.set(markerId, list);
  }

  function normalizeOffsetPx(offset){
    if(Array.isArray(offset) && offset.length >= 2){
      const [x,y] = offset;
      return [Number.isFinite(+x) ? +x : 0, Number.isFinite(+y) ? +y : 0];
    }
    return [0,0];
  }

  function computeAnchoredLatLng(marker, offsetPx=[0,0]){
    if(!marker?.getLatLng) return null;
    const markerLatLng = marker.getLatLng();
    if(!map?.latLngToLayerPoint || !map?.layerPointToLatLng) return markerLatLng;
    const markerPoint = map.latLngToLayerPoint(markerLatLng);
    const [dx,dy] = normalizeOffsetPx(offsetPx);
    const anchorPoint = markerPoint.add(L.point(dx, dy));
    return map.layerPointToLatLng(anchorPoint);
  }

  function syncAnchoredTextPosition(textLayer, marker){
    const offsetPx = textLayer.options?.meta?.offsetPx;
    if(!offsetPx) return;
    const target = computeAnchoredLatLng(marker, offsetPx);
    if(target) textLayer.setLatLng(target);
  }

  function attachTextToMarker(textLayer, marker){
    if(!textLayer || !marker) return;
    const markerId = marker.options?.meta?.id;
    if(!markerId) return;
    let offsetPx = textLayer.options?.meta?.offsetPx;
    if((!offsetPx || !Array.isArray(offsetPx)) && map?.latLngToLayerPoint && textLayer.getLatLng){
      const markerPoint = map.latLngToLayerPoint(marker.getLatLng());
      const textPoint = map.latLngToLayerPoint(textLayer.getLatLng());
      if(markerPoint && textPoint){
        offsetPx = [textPoint.x - markerPoint.x, textPoint.y - markerPoint.y];
      }
    }
    const normalizedOffset = normalizeOffsetPx(offsetPx || [0,0]);
    textLayer.options.meta.attachedTo = markerId;
    textLayer.options.meta.offsetPx = normalizedOffset;
    if(!marker._attachedTexts) marker._attachedTexts = new Set();
    marker._attachedTexts.add(textLayer);
    textLayer._attachedTo = marker;
    anchoredTextLayers.add(textLayer);
    const target = computeAnchoredLatLng(marker, normalizedOffset);
    if(target) textLayer.setLatLng(target);
    ensureMarkerAttachmentHandlers(marker);
  }

  function queueTextForMarker(textLayer, markerId){
    if(!markerId) return;
    const list = pendingTextAttachments.get(markerId) || [];
    list.push(textLayer);
    pendingTextAttachments.set(markerId, list);
  }

  function queueManeuverForMarker(polyline, markerId, role){
    if(!markerId || !polyline || !role) return;
    const list = pendingManeuverAttachments.get(markerId) || [];
    list.push({ polyline, role });
    pendingManeuverAttachments.set(markerId, list);
  }

  function removeQueuedManeuverAttachment(markerId, polyline, role){
    if(!markerId) return;
    const list = pendingManeuverAttachments.get(markerId);
    if(!list) return;
    const next = list.filter(item => item.polyline !== polyline || item.role !== role);
    if(next.length) pendingManeuverAttachments.set(markerId, next);
    else pendingManeuverAttachments.delete(markerId);
  }

  function attachManeuverAnchor(polyline, marker, role){
    if(!polyline || !marker || !role) return;
    const meta = polyline.options?.meta || (polyline.options.meta = { kind:'maneuver' });
    const markerMeta = marker.options.meta || (marker.options.meta = { kind:'nato' });
    if(!markerMeta.id) markerMeta.id = generateOverlayId('nato');
    const markerId = markerMeta.id;
    if(role === 'start') meta.startAnchorId = markerId;
    else if(role === 'end') meta.endAnchorId = markerId;
    if(!polyline._maneuverAnchors) polyline._maneuverAnchors = {};
    polyline._maneuverAnchors[role] = marker;
    if(!marker._attachedManeuvers) marker._attachedManeuvers = new Map();
    marker._attachedManeuvers.set(polyline, role);
    const latlngs = polyline.getLatLngs?.();
    const anchorLatLng = marker.getLatLng?.();
    if(Array.isArray(latlngs) && latlngs.length >= 2 && anchorLatLng){
      if(role === 'start') latlngs[0] = anchorLatLng;
      else latlngs[latlngs.length - 1] = anchorLatLng;
      polyline.setLatLngs(latlngs);
      refreshManeuverLengthLabel(polyline);
    }
    ensureMarkerAttachmentHandlers(marker);
    removeQueuedManeuverAttachment(markerId, polyline, role);
  }

  function detachManeuverAnchor(polyline, role){
    if(!polyline || !role) return;
    const meta = polyline.options?.meta || {};
    const anchors = polyline._maneuverAnchors || {};
    const marker = anchors[role] || null;
    const markerIdFromMeta = role === 'start' ? meta.startAnchorId : meta.endAnchorId;
    if(marker?._attachedManeuvers instanceof Map){
      marker._attachedManeuvers.delete(polyline);
    }
    if(markerIdFromMeta) removeQueuedManeuverAttachment(markerIdFromMeta, polyline, role);
    if(marker?.options?.meta?.id) removeQueuedManeuverAttachment(marker.options.meta.id, polyline, role);
    if(role === 'start') meta.startAnchorId = null;
    else if(role === 'end') meta.endAnchorId = null;
    if(polyline._maneuverAnchors){
      delete polyline._maneuverAnchors[role];
      if(!Object.keys(polyline._maneuverAnchors).length) delete polyline._maneuverAnchors;
    }
    maybeCleanupMarkerAttachments(marker);
  }

  function detachManeuver(polyline){
    if(!polyline) return;
    detachManeuverAnchor(polyline, 'start');
    detachManeuverAnchor(polyline, 'end');
    Array.from(pendingManeuverAttachments.entries()).forEach(([markerId, list]) => {
      const next = list.filter(item => item.polyline !== polyline);
      if(next.length) pendingManeuverAttachments.set(markerId, next);
      else pendingManeuverAttachments.delete(markerId);
    });
  }

  function maybeCleanupMarkerAttachments(marker){
    if(!marker) return;
    const hasRanges = marker._attachedRanges && marker._attachedRanges.size > 0;
    const hasTexts = marker._attachedTexts && marker._attachedTexts.size > 0;
    const hasManeuvers = marker._attachedManeuvers instanceof Map && marker._attachedManeuvers.size > 0;
    if(!hasRanges) delete marker._attachedRanges;
    if(!hasTexts) delete marker._attachedTexts;
    if(!hasManeuvers) delete marker._attachedManeuvers;
    if(!hasRanges && !hasTexts && !hasManeuvers && marker._attachmentHandler){
      marker.off('drag', marker._attachmentHandler);
      marker.off('move', marker._attachmentHandler);
      marker._attachmentHandler = null;
    }
  }

  function registerMarker(layer){
    if(!layer.options.meta) layer.options.meta = { kind:'nato' };
    if(!layer.options.meta.id) layer.options.meta.id = generateOverlayId('nato');
    const id = layer.options.meta.id;
    overlayIndex.set(id, layer);
    const queued = pendingRangeAttachments.get(id);
    if(queued){
      queued.forEach(range => attachRangeToMarker(range, layer));
      pendingRangeAttachments.delete(id);
    }
    const queuedText = pendingTextAttachments.get(id);
    if(queuedText){
      queuedText.forEach(textLayer => attachTextToMarker(textLayer, layer));
      pendingTextAttachments.delete(id);
    }
    const queuedManeuvers = pendingManeuverAttachments.get(id);
    if(queuedManeuvers){
      queuedManeuvers.forEach(({ polyline, role }) => attachManeuverAnchor(polyline, layer, role));
      pendingManeuverAttachments.delete(id);
    }
  }

  function detachRange(range){
    const anchorId = range.options?.meta?.attachedTo || null;
    if(anchorId && !range._attachedTo){
      const pending = pendingRangeAttachments.get(anchorId);
      if(pending){
        const next = pending.filter(item => item !== range);
        if(next.length) pendingRangeAttachments.set(anchorId, next);
        else pendingRangeAttachments.delete(anchorId);
      }
    }
    const marker = range._attachedTo;
    if(marker?._attachedRanges){
      marker._attachedRanges.delete(range);
    }
    range._attachedTo = null;
    if(range.options?.meta) range.options.meta.attachedTo = null;
    destroyRangeHandle(range);
    maybeCleanupMarkerAttachments(marker);
  }

  function detachText(textLayer){
    const anchorId = textLayer.options?.meta?.attachedTo || null;
    if(anchorId && !textLayer._attachedTo){
      const pending = pendingTextAttachments.get(anchorId);
      if(pending){
        const next = pending.filter(item => item !== textLayer);
        if(next.length) pendingTextAttachments.set(anchorId, next);
        else pendingTextAttachments.delete(anchorId);
      }
    }
    const marker = textLayer._attachedTo;
    if(marker?._attachedTexts){
      marker._attachedTexts.delete(textLayer);
    }
    textLayer._attachedTo = null;
    if(textLayer.options?.meta) textLayer.options.meta.attachedTo = null;
    anchoredTextLayers.delete(textLayer);
    maybeCleanupMarkerAttachments(marker);
  }

  function unregisterMarker(layer){
    const id = layer.options?.meta?.id;
    if(!id) return;
    overlayIndex.delete(id);
    if(layer._attachedRanges){
      [...layer._attachedRanges].forEach(range => {
        overlayLayer.removeLayer(range);
      });
    }
    if(layer._attachedTexts){
      [...layer._attachedTexts].forEach(textLayer => {
        overlayLayer.removeLayer(textLayer);
      });
    }
    if(layer._attachedManeuvers instanceof Map){
      [...layer._attachedManeuvers.entries()].forEach(([polyline, role]) => {
        detachManeuverAnchor(polyline, role);
      });
    }
    maybeCleanupMarkerAttachments(layer);
  }

  overlayLayer.on('layeradd', e => {
    const layer = e.layer;
    const kind = layer?.options?.meta?.kind;
    if(kind === 'nato'){
      registerMarker(layer);
    } else if(kind === 'weaponRange'){
      ensureRangeHandle(layer);
      updateRangeHandlePosition(layer);
      const anchorId = layer.options.meta.attachedTo;
      if(anchorId){
        const marker = overlayIndex.get(anchorId);
        if(marker) attachRangeToMarker(layer, marker);
        else queueRangeForMarker(layer, anchorId);
      }
    } else if(kind === 'text'){
      const anchorId = layer.options.meta?.attachedTo;
      if(anchorId){
        const marker = overlayIndex.get(anchorId);
        if(marker) attachTextToMarker(layer, marker);
        else queueTextForMarker(layer, anchorId);
      }
    } else if(kind === 'maneuver'){
      const meta = layer.options.meta || {};
      const startAnchorId = meta.startAnchorId || null;
      const endAnchorId = meta.endAnchorId || null;
      if(startAnchorId && (!layer._maneuverAnchors || !layer._maneuverAnchors.start)){
        const marker = overlayIndex.get(startAnchorId);
        if(marker) attachManeuverAnchor(layer, marker, 'start');
        else queueManeuverForMarker(layer, startAnchorId, 'start');
      }
      if(endAnchorId && (!layer._maneuverAnchors || !layer._maneuverAnchors.end)){
        const marker = overlayIndex.get(endAnchorId);
        if(marker) attachManeuverAnchor(layer, marker, 'end');
        else queueManeuverForMarker(layer, endAnchorId, 'end');
      }
      attachManeuverLengthLabel(layer);
    }
  });

  overlayLayer.on('layerremove', e => {
    const layer = e.layer;
    const kind = layer?.options?.meta?.kind;
    if(kind === 'nato'){
      unregisterMarker(layer);
    } else if(kind === 'weaponRange'){
      detachRange(layer);
    } else if(kind === 'text'){
      detachText(layer);
    } else if(kind === 'maneuver'){
      detachManeuver(layer);
    }
  });

  map.on('zoom', () => {
    anchoredTextLayers.forEach(textLayer => {
      const marker = textLayer._attachedTo;
      const offsetPx = textLayer.options?.meta?.offsetPx;
      if(!marker || !offsetPx) return;
      const target = computeAnchoredLatLng(marker, offsetPx);
      if(target) textLayer.setLatLng(target);
    });
    weaponRangeLayers.forEach(range => updateRangeHandlePosition(range));
  });

  function capturePathStyle(layer){
    return {
      color: layer.options.color,
      weight: layer.options.weight,
      dashArray: layer.options.dashArray,
      fillColor: layer.options.fillColor,
      fillOpacity: layer.options.fillOpacity
    };
  }

  function clearSelection(){
    if(!selected) return;
    if(selected._icon){
      selected._icon.style.outline='';
    } else if(selected.setStyle && selected.options._selectedBackup){
      selected.setStyle(selected.options._selectedBackup);
      delete selected.options._selectedBackup;
    }
    selected=null;
  }
  function selectLayer(l){
    if(measurementActive) return;
    clearSelection();
    selected=l;
    if(l._icon){
      l._icon.style.outline='2px solid #111827';
    } else if(l.setStyle){
      l.options._selectedBackup = capturePathStyle(l);
      const highlight = { color:'#111827', weight:(l.options.weight || 2)+1 };
      if(!l.options.fillColor) highlight.dashArray = '4,3';
      l.setStyle(highlight);
    }
  }
  function stopLeafletEvent(e){
    const original = e?.originalEvent;
    if(original){
      if(L?.DomEvent?.stop) L.DomEvent.stop(original);
      else {
        original.stopPropagation?.();
        original.preventDefault?.();
      }
      return;
    }
    if(!e) return;
    if(L?.DomEvent?.stop) L.DomEvent.stop(e);
    else {
      e.stopPropagation?.();
      e.preventDefault?.();
    }
  }
  function attachSelectablePath(layer){
    layer.on('click', e => {
      if(measurementActive){
        measurementHandlePoint?.(e.latlng);
        stopLeafletEvent(e);
        return;
      }
      selectLayer(layer);
      stopLeafletEvent(e);
    });
  }
  function resetManeuverDraft(){
    maneuverStart = null;
    maneuverStartAnchor = null;
    if(maneuverGuide){ map.removeLayer(maneuverGuide); maneuverGuide=null; }
    if(maneuverGuideTooltip){ map.removeLayer(maneuverGuideTooltip); maneuverGuideTooltip=null; }
  }

  const toolTabs = Array.from(document.querySelectorAll('.twic-tab'));
  const DEFAULT_OVERLAY_PANEL = 'nato';
  let openOverlayPanel =
    toolTabs.find(btn => btn.dataset?.panel === DEFAULT_OVERLAY_PANEL)?.dataset?.panel ||
    toolTabs[0]?.dataset?.panel ||
    DEFAULT_OVERLAY_PANEL;
  const textOpts = document.getElementById('textOpts');
  const natoOpts = document.getElementById('natoOpts');
  const weaponOpts = document.getElementById('weaponOpts');
  const maneuverOpts = document.getElementById('maneuverOpts');

  const weaponRadius = document.getElementById('weaponRadius');
  const weaponStroke = document.getElementById('weaponStroke');
  const weaponFill = document.getElementById('weaponFill');
  const weaponOpacity = document.getElementById('weaponOpacity');
  const maneuverColor = document.getElementById('maneuverColor');
  const maneuverWidth = document.getElementById('maneuverWidth');
  const maneuverDash = document.getElementById('maneuverDash');
  const btnPlaceText = document.getElementById('btnPlaceText');
  const btnPlaceNato = document.getElementById('btnPlaceNato');
  const btnPlaceRange = document.getElementById('btnPlaceRange');
  const btnExecuteManeuver = document.getElementById('btnExecuteManeuver');
  const btnPlaceManeuver = document.getElementById('btnPlaceManeuver');

  function beginSinglePlacement(mode){
    if(!mode) return;
    measurementCancel?.();
    setOpenOverlayPanel(mode);
    singlePlacementActive = true;
    singlePlacementMode = mode;
    syncToolPanels();
    updateMapCursor();
    mapEl.focus();
  }

  function finishSinglePlacement(){
    singlePlacementActive = false;
    singlePlacementMode = null;
    syncToolPanels();
    updateMapCursor();
  }

  function maybeCompleteSinglePlacement(mode){
    if(!singlePlacementActive) return;
    if(singlePlacementMode && singlePlacementMode !== mode) return;
    finishSinglePlacement();
  }

  function cancelSinglePlacement(){
    if(!singlePlacementActive) return;
    finishSinglePlacement();
  }

  btnPlaceText?.addEventListener('click', () => beginSinglePlacement('text'));
  btnPlaceNato?.addEventListener('click', () => beginSinglePlacement('nato'));
  btnPlaceRange?.addEventListener('click', () => beginSinglePlacement('weaponRange'));
  btnExecuteManeuver?.addEventListener('click', executeManeuvers);
  btnPlaceManeuver?.addEventListener('click', () => beginSinglePlacement('maneuver'));

  function syncToolPanels(){
    toolTabs.forEach(btn => btn.classList.toggle('active', btn.dataset.panel === openOverlayPanel));
    textOpts.style.display = (openOverlayPanel === 'text') ? '' : 'none';
    natoOpts.style.display = (openOverlayPanel === 'nato') ? '' : 'none';
    weaponOpts.style.display = (openOverlayPanel === 'weaponRange') ? '' : 'none';
    maneuverOpts.style.display = (openOverlayPanel === 'maneuver') ? '' : 'none';
    const maneuverActive = (singlePlacementActive && singlePlacementMode === 'maneuver');
    const placementActive = singlePlacementActive && !maneuverActive;
    setOverlayPointerPassthrough('maneuver', maneuverActive);
    setOverlayPointerPassthrough('placement', placementActive);
    if(!maneuverActive) resetManeuverDraft();
    updateMapCursor();
  }

  function setOpenOverlayPanel(panel){
    if(!panel) return;
    openOverlayPanel = panel;
    syncToolPanels();
  }

  toolTabs.forEach(btn => {
    btn.addEventListener('click', () => {
      if(btn.dataset?.panel){
        cancelSinglePlacement();
        setOpenOverlayPanel(btn.dataset.panel);
      }
    });
  });

  syncToolPanels();

  /* Text boxes */
  function makeTextDivIcon(t, s=12, c='#111', bg='#fff', bo='#e5e7eb'){
    const html = `<div class="twic-text" style="font-size:${s}px;color:${c};background:${bg};border-color:${bo};">${t.replace(/</g,'&lt;')}</div>`;
    return L.divIcon({ className:'', html, iconSize:null });
  }

  function bindTextMarkerEvents(marker){
    if(!marker) return;
    marker.on('click', e => {
      if(measurementActive){
        measurementHandlePoint?.(e.latlng);
        e.originalEvent?.stopPropagation?.();
        return;
      }
      selectLayer(marker); e.originalEvent.stopPropagation();
    });
    marker.on('dragstart', clearSelection);
    marker.on('dragend', () => {
      updateAnchoredTextOffsetFromPosition(marker);
    });
  }

  function defaultTextAnchorOffset(marker){
    const iconSize = marker?.options?.icon?.options?.iconSize;
    let width = 36;
    if(Array.isArray(iconSize) && iconSize.length){
      width = Number(iconSize[0]) || width;
    } else if(Number.isFinite(iconSize)){
      width = Number(iconSize) || width;
    }
    return [Math.round(width / 2 + 12), 0];
  }

  function resolveAnchorMarker(anchorMeta){
    if(!anchorMeta) return null;
    if(anchorMeta.marker) return anchorMeta.marker;
    const markerId = anchorMeta.markerId;
    if(markerId) return overlayIndex.get(markerId) || null;
    return null;
  }

  function updateAnchoredTextOffsetFromPosition(textLayer){
    const meta = textLayer?.options?.meta;
    const anchorId = meta?.attachedTo;
    if(!anchorId) return;
    const marker = overlayIndex.get(anchorId) || textLayer._attachedTo;
    if(!marker?.getLatLng) return;
    if(!map?.latLngToLayerPoint) return;
    const anchorPoint = map.latLngToLayerPoint(marker.getLatLng());
    const textPoint = map.latLngToLayerPoint(textLayer.getLatLng());
    if(!anchorPoint || !textPoint) return;
    const dx = textPoint.x - anchorPoint.x;
    const dy = textPoint.y - anchorPoint.y;
    const offset = [dx, dy];
    const normalized = normalizeOffsetPx(offset);
    meta.offsetPx = normalized;
    textLayer.options.meta = meta;
    if(marker){
      if(!marker._attachedTexts) marker._attachedTexts = new Set();
      marker._attachedTexts.add(textLayer);
      textLayer._attachedTo = marker;
      anchoredTextLayers.add(textLayer);
      ensureMarkerAttachmentHandlers(marker);
    }
  }

  function addTextAt(p, anchorMeta=null){
    const t = txtText.value || 'Label';
    const s = +txtSize.value || 12;
    const c = txtColor.value;
    const bg= txtBg.value;
    const b = txtBorder.value;
    const meta = { kind:'text', text:t, size:s, color:c, bg, border:b };
    let targetLatLng = p;
    let anchorMarker = resolveAnchorMarker(anchorMeta);
    let offsetPx = null;
    if(anchorMarker){
      if(!anchorMarker.options.meta) anchorMarker.options.meta = { kind:'nato' };
      if(!anchorMarker.options.meta.id) anchorMarker.options.meta.id = generateOverlayId('nato');
      offsetPx = normalizeOffsetPx(anchorMeta?.offsetPx || defaultTextAnchorOffset(anchorMarker));
      meta.attachedTo = anchorMarker.options.meta.id;
      meta.offsetPx = offsetPx;
      const anchoredLatLng = computeAnchoredLatLng(anchorMarker, offsetPx);
      if(anchoredLatLng) targetLatLng = anchoredLatLng;
    }
    const marker = L.marker(targetLatLng, { icon: makeTextDivIcon(t,s,c,bg,b), draggable:true }).addTo(overlayLayer);
    marker.options.meta = meta;
    bindTextMarkerEvents(marker);
    maybeCompleteSinglePlacement('text');
    return marker;
  }

  /* NATO symbol mapping (Air/Surface/Ground/Subsurface × Friendly/Hostile/Neutral) */
  const SIDC_MAP = {
    // Ground (unit – Infantry, Present)
    G: { base:"SUG-UCI----D", F:"SFG-UCI----D", H:"SHG-UCI----D", N:"SNG-UCI----D" },
    // Air (track – generic aircraft)
    A: { base:"SUAPMFQA----", F:"SFAPMFQA----", H:"SHAPMFQA----", N:"SNAPMFQA----" },
    // Surface (sea surface track – generic ship)
    S: { base:"SUSPMFQA----", F:"SFSPMFQA----", H:"SHSPMFQA----", N:"SNSPMFQA----" },
    // Subsurface (submarine track)
    U: { base:"SUUPMFQA----", F:"SFUPMFQA----", H:"SHUPMFQA----", N:"SNUPMFQA----" }
  };
  function getSidc(domain, aff){
    const cat = SIDC_MAP[domain];
    if(!cat) return null;
    if(cat[aff]) return cat[aff];
    const b = cat.base;
    return aff + b.slice(1); // swap affiliation letter
  }
  function makeNatoIcon(domain, aff, size=36){
    try{
      const sidc = getSidc(domain, aff);
      if(!sidc) throw new Error(`Unknown domain ${domain}`);
      if(!window.ms || !ms.Symbol) throw new Error('milsymbol not loaded');
      // Frame/background only (no center pictogram)
      const sym = new ms.Symbol(sidc, {
        size,
        icon: false,
        fill: true,
        frame: true,
        outlineWidth: size*0.06
      });
      const url = sym.asCanvas().toDataURL();
      return L.icon({ iconUrl:url, iconSize:[size,size] });
    }catch(err){
      console.error('NATO render failed:', err);
      return L.divIcon({
        className:'',
        html:`<div style="width:${size/3}px;height:${size/3}px;border-radius:50%;background:#111"></div>`,
        iconSize:[size/3,size/3]
      });
    }
  }
  function addNatoAt(p){
    const d = natoDomain.value;   // A/S/G/U
    const a = natoAff.value;      // F/H/N
    const s = +natoSize.value || 36;
    const id = generateOverlayId('nato');
    const m = L.marker(p, { icon: makeNatoIcon(d,a,s), draggable:true });
    m.options.meta = { kind:'nato', domain:d, aff:a, size:s, id };
    m.addTo(overlayLayer);
    m.on('click', e => {
      if(measurementActive){
        measurementHandlePoint?.(e.latlng);
        e.originalEvent?.stopPropagation?.();
        return;
      }
      const mode = singlePlacementActive ? singlePlacementMode : null;
      if(mode === 'text'){
        const offsetPx = defaultTextAnchorOffset(m);
        addTextAt(m.getLatLng(), { marker: m, offsetPx });
        e.originalEvent?.stopPropagation?.();
        return;
      }
      if(mode === 'maneuver'){
        handleManeuverClick(m.getLatLng(), m);
        e.originalEvent?.stopPropagation?.();
        return;
      }
      if(mode === 'weaponRange'){
        dropWeaponRangeForMarker(m);
        e.originalEvent?.stopPropagation?.();
        return;
      }
      selectLayer(m); e.originalEvent.stopPropagation();
    });
    m.on('dragstart', clearSelection);
    maybeCompleteSinglePlacement('nato');
  }

  function dashPatternFromValue(val){
    switch(val){
      case 'dashed': return '10,6';
      case 'dotted': return '3,6';
      default: return '';
    }
  }
  function dropWeaponRangeForMarker(marker){
    if(!marker) return null;
    const latlng = marker.getLatLng?.();
    if(!latlng) return null;
    const circle = addWeaponRangeAt(latlng, marker);
    if(circle) attachRangeToMarker(circle, marker);
    return circle;
  }
  function addWeaponRangeAt(p, marker=null){
    const radiusNm = Math.max(0, +weaponRadius.value || 0);
    if(!radiusNm) return;
    const stroke = weaponStroke.value || '#ef4444';
    const fill = weaponFill.value || stroke;
    const fillOpacity = Math.min(1, Math.max(0, parseFloat(weaponOpacity.value) || 0));
    const anchorMarker = marker ?? ((selected && selected.options?.meta?.kind === 'nato') ? selected : null);
    if(anchorMarker){
      const meta = anchorMarker.options.meta || (anchorMarker.options.meta = { kind:'nato' });
      if(!meta.kind) meta.kind = 'nato';
      if(!meta.id) meta.id = generateOverlayId('nato');
    }
    const center = anchorMarker ? anchorMarker.getLatLng() : p;
    const circle = L.circle(center, {
      radius: radiusNm / UNITS_PER_PIXEL,
      color: stroke,
      weight: 2,
      fillColor: fill,
      fillOpacity
    });
    const attachedTo = anchorMarker?.options?.meta?.id || null;
    circle.options.meta = { kind:'weaponRange', radiusNm, color: stroke, fillColor: fill, fillOpacity, attachedTo };
    circle.addTo(overlayLayer);
    attachSelectablePath(circle);
    ensureRangeHandle(circle);
    maybeCompleteSinglePlacement('weaponRange');
    return circle;
  }
  function handleManeuverClick(p, anchorMarker=null){
    const color = maneuverColor.value || '#2563eb';
    const weight = +maneuverWidth.value || 3;
    const dashArray = dashPatternFromValue(maneuverDash.value);
    if(anchorMarker){
      const meta = anchorMarker.options.meta || (anchorMarker.options.meta = { kind:'nato' });
      if(!meta.id) meta.id = generateOverlayId('nato');
    }
    if(!maneuverStart){
      const startLatLng = anchorMarker?.getLatLng?.() || p;
      maneuverStart = startLatLng;
      maneuverStartAnchor = anchorMarker || null;
      maneuverGuide = L.polyline([startLatLng,startLatLng], { color, weight, dashArray, opacity:0.6, interactive:false }).addTo(map);
      maneuverGuideTooltip = L.tooltip({
        permanent: true,
        direction: 'center',
        className: 'twic-badge twic-badge--maneuver',
        offset: [0, 0],
        opacity: 1
      }).setContent(formatNauticalMiles(0)).setLatLng(startLatLng).addTo(map);
    } else {
      const startLatLng = maneuverStartAnchor?.getLatLng?.() || maneuverStart;
      const endMarker = anchorMarker || null;
      const endLatLng = endMarker?.getLatLng?.() || p;
      const latlngs = [startLatLng, endLatLng];
      const poly = L.polyline(latlngs, { color, weight, dashArray });
      const meta = { kind:'maneuver', color, weight, dashArray, startAnchorId: null, endAnchorId: null };
      if(maneuverStartAnchor){
        const startMeta = maneuverStartAnchor.options.meta || (maneuverStartAnchor.options.meta = { kind:'nato' });
        if(!startMeta.id) startMeta.id = generateOverlayId('nato');
        meta.startAnchorId = startMeta.id;
      }
      if(endMarker){
        const endMeta = endMarker.options.meta || (endMarker.options.meta = { kind:'nato' });
        if(!endMeta.id) endMeta.id = generateOverlayId('nato');
        meta.endAnchorId = endMeta.id;
      }
      poly.options.meta = meta;
      poly.addTo(overlayLayer);
      attachSelectablePath(poly);
      attachManeuverLengthLabel(poly);
      if(maneuverStartAnchor) attachManeuverAnchor(poly, maneuverStartAnchor, 'start');
      if(endMarker) attachManeuverAnchor(poly, endMarker, 'end');
      resetManeuverDraft();
      maybeCompleteSinglePlacement('maneuver');
    }
  }
  map.on('mousemove', e => {
    if(maneuverStart && maneuverGuide){
      const startLatLng = maneuverStartAnchor?.getLatLng?.() || maneuverStart;
      maneuverGuide.setLatLngs([startLatLng, e.latlng]);
      if(maneuverGuideTooltip){
        const midpoint = midpointLatLng(startLatLng, e.latlng);
        if(midpoint){
          const lengthNm = computeLineLengthNm(startLatLng, e.latlng);
          maneuverGuideTooltip.setLatLng(midpoint).setContent(formatNauticalMiles(lengthNm));
        }
      }
    }
  });

  function easeInOut(t){
    if(t < 0.5) return 2 * t * t;
    return -1 + (4 - 2 * t) * t;
  }

  function animateMarkerTo(marker, targetLatLng, duration=1200){
    if(!marker?.getLatLng || !targetLatLng) return Promise.resolve();
    const startLatLng = marker.getLatLng();
    if(!startLatLng) return Promise.resolve();
    const start = L.latLng(startLatLng);
    const end = L.latLng(targetLatLng);
    if(!Number.isFinite(start.lat) || !Number.isFinite(start.lng) ||
       !Number.isFinite(end.lat)   || !Number.isFinite(end.lng)){
      return Promise.resolve();
    }
    if(start.lat === end.lat && start.lng === end.lng) return Promise.resolve();
    const existing = activeMarkerAnimations.get(marker);
    if(existing?.cancel) existing.cancel();
    if(typeof requestAnimationFrame !== 'function' || typeof cancelAnimationFrame !== 'function'){
      marker.setLatLng([end.lat, end.lng]);
      return Promise.resolve();
    }
    return new Promise(resolve => {
      const state = { cancel: null, cancelled: false, rafId: null };
      const nowFn = (typeof performance !== 'undefined' && performance.now) ? () => performance.now() : () => Date.now();
      const startTime = nowFn();
      const durationMs = Math.max(0, Number(duration) || 0);
      const onRemove = () => state.cancel?.();
      marker.once('remove', onRemove);

      function finish(){
        if(state.cancelled) return;
        marker.off('remove', onRemove);
        activeMarkerAnimations.delete(marker);
        marker.setLatLng([end.lat, end.lng]);
        resolve();
      }

      function step(now){
        if(state.cancelled) return;
        const current = typeof now === 'number' ? now : nowFn();
        const elapsed = current - startTime;
        const linearT = durationMs > 0 ? Math.min(1, elapsed / durationMs) : 1;
        const t = easeInOut(linearT);
        const lat = start.lat + (end.lat - start.lat) * t;
        const lng = start.lng + (end.lng - start.lng) * t;
        marker.setLatLng([lat, lng]);
        if(linearT < 1){
          state.rafId = requestAnimationFrame(step);
        } else {
          finish();
        }
      }

      state.cancel = () => {
        if(state.cancelled) return;
        state.cancelled = true;
        if(state.rafId) cancelAnimationFrame(state.rafId);
        marker.off('remove', onRemove);
        activeMarkerAnimations.delete(marker);
        resolve();
      };

      activeMarkerAnimations.set(marker, state);
      state.rafId = requestAnimationFrame(step);
    });
  }

  function executeManeuvers(){
    resetManeuverDraft();
    const markerTargets = new Map();
    overlayLayer.eachLayer(layer => {
      if(layer?.options?.meta?.kind !== 'maneuver') return;
      const latlngs = layer.getLatLngs?.();
      if(!Array.isArray(latlngs) || latlngs.length < 2) return;
      const startLatLng = latlngs[0];
      const endLatLng = latlngs[latlngs.length - 1];
      const meta = layer.options.meta || {};
      let startMarker = layer._maneuverAnchors?.start || null;
      if(!startMarker && meta.startAnchorId) startMarker = overlayIndex.get(meta.startAnchorId) || null;
      let endMarker = layer._maneuverAnchors?.end || null;
      if(!endMarker && meta.endAnchorId) endMarker = overlayIndex.get(meta.endAnchorId) || null;
      if(startMarker && !markerTargets.has(startMarker)){
        markerTargets.set(startMarker, L.latLng(endLatLng));
      }
      if(endMarker && !markerTargets.has(endMarker)){
        markerTargets.set(endMarker, L.latLng(startLatLng));
      }
    });
    if(!markerTargets.size) return;
    const animations = [];
    markerTargets.forEach((target, marker) => {
      animations.push(animateMarkerTo(marker, target));
    });
    return Promise.allSettled(animations).then(() => {
      if(typeof saveOverlays === 'function') saveOverlays();
    });
  }
  document.addEventListener('keydown', e => {
    if(e.key !== 'Escape') return;
    if(singlePlacementMode === 'maneuver') resetManeuverDraft();
    cancelSinglePlacement();
  });

  map.on('click', e => {
    if (measurementActive) return;
    if(!singlePlacementActive){
      clearSelection();
      return;
    }
    if (singlePlacementMode === 'text') {
      let anchorMeta = null;
      const isNatoMarker = selected?.options?.meta?.kind === 'nato';
      if (isNatoMarker && typeof selected.getLatLng === 'function') {
        const markerLatLng = selected.getLatLng();
        if (markerLatLng && map?.latLngToLayerPoint) {
          const markerPoint = map.latLngToLayerPoint(markerLatLng);
          const clickPoint = map.latLngToLayerPoint(e.latlng);
          if (markerPoint && clickPoint) {
            const offsetPx = [clickPoint.x - markerPoint.x, clickPoint.y - markerPoint.y];
            anchorMeta = { marker: selected, offsetPx };
          }
        }
        if (!anchorMeta) {
          anchorMeta = { marker: selected };
        }
      }
      addTextAt(e.latlng, anchorMeta);
    }
    else if (singlePlacementMode === 'nato') addNatoAt(e.latlng);
    else if (singlePlacementMode === 'weaponRange') {
      const anchor = (selected && selected.options?.meta?.kind === 'nato') ? selected : null;
      if(anchor) dropWeaponRangeForMarker(anchor);
      else addWeaponRangeAt(e.latlng);
    }
    else if (singlePlacementMode === 'maneuver') handleManeuverClick(e.latlng, null);
  });

  document.getElementById('btnDelete').onclick = () => { if (selected) { overlayLayer.removeLayer(selected); selected=null; } };
  document.getElementById('btnOverlayClear').onclick = () => { overlayLayer.clearLayers(); selected=null; resetManeuverDraft(); };
  mapEl.addEventListener('keydown', e => {
    if ((e.key === 'Delete' || e.key === 'Backspace') && selected) {
      overlayLayer.removeLayer(selected); selected=null;
    }
  });

  /* ===== Shared overlays: share-link (URL hash) + repo file fallback ===== */


  function overlaysToFeatureCollection() {
    const feats = [];
    overlayLayer.eachLayer(layer => {
      const metaKind = layer.options?.meta?.kind;

      if (metaKind === 'maneuver') {
        const latlngs = layer.getLatLngs?.() || [];
        if (!latlngs.length) return;
        const coords = latlngs.map(ll => [ll.lng, ll.lat]);
        feats.push({
          type:'Feature',
          geometry:{ type:'LineString', coordinates: coords },
          properties:{
            kind:'maneuver',
            color: layer.options.meta.color,
            weight: layer.options.meta.weight,
            dashArray: layer.options.meta.dashArray || '',
            startAnchorId: layer.options.meta.startAnchorId || null,
            endAnchorId: layer.options.meta.endAnchorId || null
          }
        });
        return;
      }

      if (metaKind === 'weaponRange') {
        if (!layer.getLatLng) return;
        const center = layer.getLatLng();
        feats.push({
          type:'Feature',
          geometry:{ type:'Point', coordinates:[center.lng, center.lat] },
          properties:{
            kind:'weaponRange',
            radiusNm: layer.options.meta.radiusNm,
            color: layer.options.meta.color,
            fillColor: layer.options.meta.fillColor,
            fillOpacity: layer.options.meta.fillOpacity,
            attachedTo: layer.options.meta.attachedTo || null
          }
        });
        return;
      }

      if (!layer.getLatLng) return;
      const p = layer.getLatLng();

      if (layer.options.meta?.kind === 'text') {
        const meta = layer.options.meta;
        const offset = Array.isArray(meta.offsetPx) ? normalizeOffsetPx(meta.offsetPx) : null;
        feats.push({
          type:'Feature',
          geometry:{ type:'Point', coordinates:[p.lng, p.lat] },
          properties:{
            kind: 'text',
            text:  meta.text ?? '',
            size:  Number.isFinite(+meta.size) ? +meta.size : 12,
            color: meta.color ?? '#111',
            bg:    meta.bg ?? '#fff',
            border:meta.border ?? '#e5e7eb',
            attachedTo: meta.attachedTo || null,
            offsetPx: offset
          }
        });
        return;
      }

      let props = { kind:'unknown' };

      if (layer.options.icon && typeof layer.options.icon.options.html === 'string') {
        const div = document.createElement('div');
        div.innerHTML = layer.options.icon.options.html;
        const el = div.firstChild;
        const style = el?.getAttribute?.('style') || '';
        props = {
          kind:  'text',
          text:  el?.textContent || '',
          size:  +(style.match(/font-size:(\d+)px/)?.[1] || 12),
          color: (style.match(/color:\s*([^;]+)/)?.[1] || '#111'),
          bg:    (style.match(/background:\s*([^;]+)/)?.[1] || '#fff'),
          border:(style.match(/border-color:\s*([^;]+)/)?.[1] || '#e5e7eb')
        };
      }

      if (layer.options.meta?.kind === 'nato') {
        props = {
          kind:   'nato',
          domain: layer.options.meta.domain, // A/S/G/U
          aff:    layer.options.meta.aff,    // F/H/N
          size:   layer.options.meta.size,
          id:     layer.options.meta.id
        };
      }

      feats.push({
        type:'Feature',
        geometry:{ type:'Point', coordinates:[p.lng, p.lat] },
        properties: props
      });
    });
    return { type:'FeatureCollection', features:feats };
  }

  function featureCollectionToOverlays(gj) {
    overlayLayer.clearLayers(); selected = null; resetManeuverDraft();
    (gj.features || []).forEach(f => {
      const k = f.properties?.kind;

      if (k === 'maneuver') {
        if (f.geometry?.type !== 'LineString') return;
        const coords = Array.isArray(f.geometry.coordinates) ? f.geometry.coordinates : [];
        const latlngs = coords.map(pt => L.latLng(pt[1], pt[0])).filter(ll => Number.isFinite(ll.lat) && Number.isFinite(ll.lng));
        if (latlngs.length < 2) return;
        const { color='#2563eb', weight=3, dashArray='', startAnchorId=null, endAnchorId=null } = f.properties || {};
        const poly = L.polyline(latlngs, { color, weight, dashArray });
        poly.options.meta = { kind:'maneuver', color, weight, dashArray, startAnchorId, endAnchorId };
        poly.addTo(overlayLayer);
        attachSelectablePath(poly);
        attachManeuverLengthLabel(poly);
        if(startAnchorId){
          const marker = overlayIndex.get(startAnchorId);
          if(marker) attachManeuverAnchor(poly, marker, 'start');
          else queueManeuverForMarker(poly, startAnchorId, 'start');
        }
        if(endAnchorId){
          const marker = overlayIndex.get(endAnchorId);
          if(marker) attachManeuverAnchor(poly, marker, 'end');
          else queueManeuverForMarker(poly, endAnchorId, 'end');
        }
        return;
      }

      if (k === 'weaponRange') {
        if (f.geometry?.type !== 'Point') return;
        const [cx,cy] = f.geometry.coordinates;
        const center = L.latLng(cy,cx);
        const { radiusNm=0, color='#ef4444', fillColor='#ef4444', fillOpacity=0.15, attachedTo=null } = f.properties || {};
        if (!radiusNm) return;
        const normalizedFill = Math.min(1, Math.max(0, +fillOpacity || 0));
        const circle = L.circle(center, {
          radius: radiusNm / UNITS_PER_PIXEL,
          color,
          weight: 2,
          fillColor,
          fillOpacity: normalizedFill
        });
        circle.options.meta = { kind:'weaponRange', radiusNm, color, fillColor, fillOpacity: normalizedFill, attachedTo };
        circle.addTo(overlayLayer);
        attachSelectablePath(circle);
        ensureRangeHandle(circle);
        return;
      }

      if (f.geometry?.type !== 'Point') return;
      const [x,y] = f.geometry.coordinates;
      const p = L.latLng(y,x);

      if (k === 'text') {
        const { text='', size=12, color='#111', bg='#fff', border='#e5e7eb', attachedTo=null, offsetPx=null } = f.properties || {};
        const normalizedOffset = Array.isArray(offsetPx) ? normalizeOffsetPx(offsetPx) : null;
        const meta = { kind:'text', text, size, color, bg, border };
        if(attachedTo){
          meta.attachedTo = attachedTo;
          if(normalizedOffset) meta.offsetPx = normalizedOffset;
        }
        let targetLatLng = p;
        if(attachedTo && normalizedOffset){
          const marker = overlayIndex.get(attachedTo);
          if(marker){
            const anchoredLatLng = computeAnchoredLatLng(marker, normalizedOffset);
            if(anchoredLatLng) targetLatLng = anchoredLatLng;
          }
        }
        const mk = L.marker(targetLatLng, { icon: makeTextDivIcon(text,size,color,bg,border), draggable:true }).addTo(overlayLayer);
        mk.options.meta = meta;
        bindTextMarkerEvents(mk);
        return;
      }
      if (k === 'nato') {
        const { domain='G', aff='F', size=36, id=null } = f.properties || {};
        const mk = L.marker(p, { icon: makeNatoIcon(domain,aff,size), draggable:true });
        mk.options.meta = { kind:'nato', domain, aff, size, id: id || generateOverlayId('nato') };
        mk.addTo(overlayLayer);
        mk.on('click', e => {
          if(measurementActive){
            measurementHandlePoint?.(e.latlng);
            e.originalEvent?.stopPropagation?.();
            return;
          }
          const mode = singlePlacementActive ? singlePlacementMode : null;
          if(mode === 'text'){
            const offsetPx = defaultTextAnchorOffset(mk);
            addTextAt(mk.getLatLng(), { marker: mk, offsetPx });
            e.originalEvent?.stopPropagation?.();
            return;
          }
          if(mode === 'maneuver'){
            handleManeuverClick(mk.getLatLng(), mk);
            e.originalEvent?.stopPropagation?.();
            return;
          }
          if(mode === 'weaponRange'){
            dropWeaponRangeForMarker(mk);
            e.originalEvent?.stopPropagation?.();
            return;
          }
          selectLayer(mk); e.originalEvent.stopPropagation();
        });
        mk.on('dragstart', clearSelection);
        return;
      }
    });
  }

  // --- Share link (hash) helpers: #s=<compressed>
  function setHashFromOverlays() {
    const fc = overlaysToFeatureCollection();
    const json = JSON.stringify(fc);
    const packed = LZString.compressToEncodedURIComponent(json);
    location.hash = 's=' + packed;
  }
  function tryLoadFromHash() {
    const h = new URL(location.href).hash.slice(1);
    if (!h.startsWith('s=')) return false;
    try {
      const packed = h.substring(2);
      const json = LZString.decompressFromEncodedURIComponent(packed);
      if (!json) return false;
      const fc = JSON.parse(json);
      featureCollectionToOverlays(fc);
      return true;
    } catch { return false; }
  }

  // --- Repo file fallback: overlays.geojson at repo root
  async function tryLoadFromRepoFile() {
    try {
      const res = await fetch('./overlays.geojson', { cache:'no-cache' });
      if (!res.ok) return false;
      const gj = await res.json();
      featureCollectionToOverlays(gj);
      return true;
    } catch { return false; }
  }

  // Bootstrap: prefer URL hash state; else fall back to repo file
  (async function bootstrapOverlays(){
    const loadedFromHash = tryLoadFromHash();
    if (!loadedFromHash) await tryLoadFromRepoFile();
  })();

  // Wire the Share button
  document.getElementById('btnShare').addEventListener('click', () => {
    setHashFromOverlays();
    navigator.clipboard?.writeText(location.href).catch(()=>{});
    alert('Shareable link updated in the address bar (copied to clipboard if permitted).');
  });
  </script>
<script>

const SUPABASE_URL = 'https://pzezmofpgtzofpveucmz.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InB6ZXptb2ZwZ3R6b2ZwdmV1Y216Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjAzNTc5NDYsImV4cCI6MjA3NTkzMzk0Nn0.DZLlxcrYgW5iTIpG-YAeRCwYGXCghN_aNWBigjnx3cI';
const ROOM_ID = 'public';  // use any string; all visitors share this document

const sb = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
</script>

let _saving = false;

async function loadFromSupabase() {
  const { data, error } = await sb
    .from('overlays')
    .select('data, updated_at')
    .eq('id', ROOM_ID)
    .single();

  if (error) { console.warn('Supabase load error:', error.message); return false; }
  if (data?.data) {
    featureCollectionToOverlays(data.data);
    return true;
  }
  return false;
}

const saveOverlays = debounce(async () => {
  const fc = overlaysToFeatureCollection();
  _saving = true;
  const { error } = await sb
    .from('overlays')
    .upsert({ id: ROOM_ID, data: fc })
    .eq('id', ROOM_ID);
  if (error) console.warn('Supabase save error:', error.message);

  setTimeout(() => { _saving = false; }, 300);
}, 350);

const channel = sb
  .channel('overlays-listen')
  .on(
    'postgres_changes',
    { event: '*', schema: 'public', table: 'overlays', filter: `id=eq.${ROOM_ID}` },
    (payload) => {
      if (_saving) return; // ignore our own save
      const next = (payload.new && payload.new.data) || null;
      if (!next) return;
      featureCollectionToOverlays(next);
    }
  )
  .subscribe();

/* Hook saves to your existing UI events */
function hookOverlaySaves() {
  // When a layer is added/removed
  overlayLayer.on('layeradd', saveOverlays);
  overlayLayer.on('layerremove', saveOverlays);


  overlayLayer.eachLayer(l => { if (l.dragging) l.on('dragend', saveOverlays); });
  overlayLayer.on('layeradd', e => {
    const layer = e.layer;
    if (layer?.dragging) layer.on('dragend', saveOverlays);
  });
}

function debounce(fn, wait=300){
  let t; return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn(...args), wait); };
}

(async function bootstrapCollab(){
  const loadedFromHash = (function(){
    try { return tryLoadFromHash(); } catch { return false; }
  })();
  if (!loadedFromHash) {
    const loadedFromRepo = await (async () => { try { return await tryLoadFromRepoFile(); } catch { return false; } })();
    if (!loadedFromRepo) {
      await loadFromSupabase(); // finally, shared doc
    }
  }
  hookOverlaySaves();
})();
</script>
</body>
</html>
