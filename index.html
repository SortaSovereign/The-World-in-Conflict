<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>The World in Conflict — Map Editor</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>

  <style>
    html, body, #map { height:100%; margin:0; background:#0f112f; }

    /* HUD, badges, toolbar */
    .twic-hud {
      position:absolute; left:8px; bottom:8px; z-index:1000;
      background:#ffffffd9; padding:6px 10px; border-radius:8px;
      font:12px/1.2 system-ui,sans-serif; box-shadow:0 2px 8px rgba(0,0,0,.15);
    }
    .twic-badge, .leaflet-tooltip.twic-badge {
      font:600 12px/1.2 system-ui,sans-serif; color:#111; background:#fff;
      border:1px solid #e5e7eb; border-radius:6px; padding:3px 6px;
      box-shadow:0 1px 6px rgba(0,0,0,.15);
      pointer-events:none;
    }
    .twic-toolbar {
      position:absolute; right:8px; top:8px; z-index:1000; display:flex; gap:6px;
    }
    .twic-btn {
      background:#fff; border:1px solid #e5e7eb; border-radius:8px; padding:6px 10px;
      font:12px system-ui; cursor:pointer; box-shadow:0 2px 8px rgba(0,0,0,.1);
    }
    .twic-btn.active { background:#111827; color:#fff; border-color:#111827; }

    /* Overlay tool panel */
    .twic-panel {
      position:absolute; right:8px; top:60px; z-index:1000;
      width:300px; background:#ffffffee; border:1px solid #e5e7eb; border-radius:12px;
      padding:10px; font:12px system-ui,sans-serif; box-shadow:0 8px 24px rgba(0,0,0,.15);
    }
    .twic-panel h3 { margin:0 0 8px; font-size:13px }
    .twic-row { display:flex; gap:8px; margin-bottom:8px; align-items:center }
    .twic-row label { min-width:84px }
    .twic-row input, .twic-row select {
      flex:1; padding:6px 8px; border:1px solid #e5e7eb; border-radius:8px;
    }
    .twic-muted { color:#6b7280; font-size:11px; margin-top:4px }
    .twic-text {
      background:#fff; border:1px solid #e5e7eb; border-radius:6px; padding:3px 6px;
      color:#111; font:600 12px/1.2 system-ui,sans-serif; white-space:pre-wrap;
    }
  </style>
</head>
<body>

  <!-- Focusable map (so Esc/Delete work on GitHub Pages) -->
  <div id="map" tabindex="0"></div>

  <!-- HUD + measurement toolbar -->
  <div class="twic-hud" id="twicHud">X,Y: —, — | Zoom: — | 1 px = —</div>
  <div class="twic-toolbar">
    <button class="twic-btn" id="measureBtn">Measure</button>
    <button class="twic-btn" id="clearBtn">Clear</button>
  </div>

  <!-- Overlay (text + NATO icons) panel -->
  <div class="twic-panel">
    <h3>Overlay Tools</h3>

    <div class="twic-row">
      <label>Mode</label>
      <select id="toolMode">
        <option value="select">Select / Move</option>
        <option value="text">Add Text</option>
        <option value="nato">Add NATO Icon</option>
        <option value="weaponRange">Weapon Range</option>
        <option value="maneuver">Line of Maneuver</option>
      </select>
    </div>

    <!-- Text box options -->
    <div id="textOpts">
      <div class="twic-row"><label>Text</label><input id="txtText" type="text" placeholder="Label…"/></div>
      <div class="twic-row">
        <label>Size</label><input id="txtSize" type="number" value="12" min="8" max="48"/>
        <label>Color</label><input id="txtColor" type="color" value="#111111"/>
      </div>
      <div class="twic-row">
        <label>BG</label><input id="txtBg" type="color" value="#ffffff"/>
        <label>Border</label><input id="txtBorder" type="color" value="#e5e7eb"/>
      </div>
      <div class="twic-muted">Click map to place a text box.</div>
      <div style="display:flex; justify-content:flex-end; margin-top:6px;">
        <button class="twic-btn" type="button" id="btnPlaceText">Place Text</button>
      </div>
    </div>

    <!-- Simplified NATO options -->
    <div id="natoOpts" style="display:none">
      <div class="twic-row">
        <label>Domain</label>
        <select id="natoDomain">
          <option value="A">Air</option>
          <option value="S">Surface</option>
          <option value="G">Ground</option>
          <option value="U">Subsurface</option>
        </select>
      </div>
      <div class="twic-row">
        <label>Affil.</label>
        <select id="natoAff">
          <option value="F">Friendly</option>
          <option value="H">Hostile</option>
          <option value="N">Neutral</option>
        </select>
        <label>Size</label><input id="natoSize" type="number" value="36" min="16" max="96"/>
      </div>
      <div class="twic-muted">Click map to place a NATO symbol.</div>
      <div style="display:flex; justify-content:flex-end; margin-top:6px;">
        <button class="twic-btn" type="button" id="btnPlaceNato">Place NATO Icon</button>
      </div>
    </div>

    <!-- Weapon engagement range options -->
    <div id="weaponOpts" style="display:none">
      <div class="twic-row"><label>Radius (nm)</label><input id="weaponRadius" type="number" value="180" min="18" step="18"/></div>
      <div class="twic-row">
        <label>Stroke</label><input id="weaponStroke" type="color" value="#ef4444"/>
        <label>Fill</label><input id="weaponFill" type="color" value="#ef4444"/>
      </div>
      <div class="twic-row"><label>Fill α</label><input id="weaponOpacity" type="number" value="0.15" min="0" max="1" step="0.05"/></div>
      <div class="twic-muted">Click map to place a range circle in nautical miles.</div>
      <div style="display:flex; justify-content:flex-end; margin-top:6px;">
        <button class="twic-btn" type="button" id="btnPlaceRange">Place Range</button>
      </div>
    </div>

    <!-- Maneuver line options -->
    <div id="maneuverOpts" style="display:none">
      <div class="twic-row">
        <label>Color</label><input id="maneuverColor" type="color" value="#2563eb"/>
        <label>Width</label><input id="maneuverWidth" type="number" value="3" min="1" max="12"/>
      </div>
      <div class="twic-row">
        <label>Dash</label>
        <select id="maneuverDash">
          <option value="solid">Solid</option>
          <option value="dashed" selected>Dashed</option>
          <option value="dotted">Dotted</option>
        </select>
      </div>
      <div class="twic-muted">Click start and end points to draw a line of maneuver.</div>
      <div style="display:flex; justify-content:flex-end; margin-top:6px;">
        <button class="twic-btn" type="button" id="btnPlaceManeuver">Place Maneuver</button>
      </div>
    </div>

    <!-- Share + overlay actions -->
    <div style="display:flex; gap:8px; flex-wrap:wrap;">
      <button class="twic-btn" id="btnShare" title="Encode overlays into the URL">Share link</button>
      <button class="twic-btn" id="btnDelete">Delete Selected</button>
      <button class="twic-btn" id="btnOverlayClear">Clear All</button>
    </div>
    <div class="twic-muted" style="margin-top:6px">
      Shared state: uses URL hash if present; otherwise loads <code>overlays.geojson</code> (if in repo).
    </div>
  </div>

  <!-- Scripts -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <!-- milsymbol UMD (use jsDelivr for correct MIME on Pages) -->
  <script src="https://cdn.jsdelivr.net/npm/milsymbol@3.0.3/dist/milsymbol.min.js"></script>
  <!-- LZ-String for shareable URL compression -->
  <script src="https://cdn.jsdelivr.net/npm/lz-string@1.5.0/libs/lz-string.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script>
  /* ===== Base map (PNG + XYZ tiles z=0..7) ===== */
  const MAX_ZOOM = 7;
  const TILE_URL = './tiles/{z}/{x}/{y}.png';

  const map = L.map('map', {
    crs: L.CRS.Simple,
    minZoom: 0,
    maxZoom: MAX_ZOOM,
    zoom: 0,
    center: [-56,128],
    updateWhenIdle: true,
    zoomAnimation: true,
    keyboard: true
  });
  const mapEl = map.getContainer();
  const overlayPane = map.getPanes().overlayPane;
  const markerPane = map.getPanes().markerPane;
  setTimeout(() => mapEl.focus(), 0);

  let toolMode = null;
  let singlePlacementActive = false;
  let singlePlacementMode = null;
  let measurementCancel = null;
  let measurementHandlePoint = null;
  let measurementActive = false;

  function updateMapCursor(){
    const mode = toolMode?.value || 'select';
    if(measurementActive){
      mapEl.style.cursor = 'crosshair';
    } else if(mode !== 'select'){
      mapEl.style.cursor = 'crosshair';
    } else {
      mapEl.style.cursor = '';
    }
  }

  L.tileLayer(TILE_URL, {
    tileSize: 256,
    minZoom: 0,
    maxZoom: MAX_ZOOM,
    noWrap: true,
    tms: false,           // you used --xyz with gdal2tiles
    detectRetina: true,
    keepBuffer: 2
  }).addTo(map);

  map.flyTo([-56,128], 2, { animate:true, duration:1.2 });

  const overlayPointerLocks = new Set();
  function updateOverlayPointerPassthrough(){
    const hasLocks = overlayPointerLocks.size > 0;
    const maneuverOnly = (overlayPointerLocks.size === 1 && overlayPointerLocks.has('maneuver'));
    const overlayValue = hasLocks ? 'none' : '';
    const markerValue = (hasLocks && !maneuverOnly) ? 'none' : '';
    if(overlayPane) overlayPane.style.pointerEvents = overlayValue;
    if(markerPane) markerPane.style.pointerEvents = markerValue;
  }
  function setOverlayPointerPassthrough(lockId, enabled){
    if(!lockId) return;
    if(enabled) overlayPointerLocks.add(lockId);
    else overlayPointerLocks.delete(lockId);
    updateOverlayPointerPassthrough();
  }

  /* ===== Coordinate HUD ===== */
  const UNITS_PER_PIXEL = 18, UNIT_NAME = 'nautical miles';
  (function addCoordinateHUD(){
    const hud = document.getElementById('twicHud');
    function render(e){
      const z = map.getZoom();
      const p = e?.latlng ?? map.getCenter();
      hud.textContent = `X,Y: ${p.lng.toFixed(0)}, ${p.lat.toFixed(0)} | Zoom: ${z} | 1 px = ${UNITS_PER_PIXEL} ${UNIT_NAME}`;
    }
    map.on('mousemove zoomend moveend', render);
    render();
  })();

  /* ===== Measurement tool ===== */

  function formatNauticalMiles(lengthNm){
    return `${lengthNm.toFixed(2)} ${UNIT_NAME}`;
  }

  function computeLineLengthNm(start, end){
    if(!start || !end) return 0;
    return Math.hypot(end.lng - start.lng, end.lat - start.lat) * UNITS_PER_PIXEL;
  }

  function midpointLatLng(start, end){
    if(!start || !end) return null;
    return L.latLng((start.lat + end.lat) / 2, (start.lng + end.lng) / 2);
  }

  function attachManeuverLengthLabel(polyline){
    if(!polyline || typeof polyline.getLatLngs !== 'function') return;
    const latlngs = polyline.getLatLngs();
    if(!Array.isArray(latlngs) || latlngs.length < 2) return;

    if(polyline._lengthTooltipRemoveHandler){
      polyline.off('remove', polyline._lengthTooltipRemoveHandler);
      polyline._lengthTooltipRemoveHandler = null;
    }
    if(polyline._lengthTooltip){
      polyline.unbindTooltip();
      polyline._lengthTooltip = null;
    }

    const start = latlngs[0];
    const end = latlngs[latlngs.length - 1];
    const nmLength = computeLineLengthNm(start, end);
    const midpoint = midpointLatLng(start, end);
    if(!midpoint) return;

    const tooltip = L.tooltip({
      permanent: true,
      direction: 'center',
      className: 'twic-badge twic-badge--maneuver',
      offset: [0, 0],
      opacity: 1
    }).setContent(formatNauticalMiles(nmLength)).setLatLng(midpoint);

    polyline.bindTooltip(tooltip);
    polyline._lengthTooltip = tooltip;

    const removeHandler = () => {
      if(polyline._lengthTooltip){
        polyline.unbindTooltip();
        polyline._lengthTooltip = null;
      }
      if(polyline._lengthTooltipRemoveHandler){
        polyline.off('remove', polyline._lengthTooltipRemoveHandler);
        polyline._lengthTooltipRemoveHandler = null;
      }
    };

    polyline._lengthTooltipRemoveHandler = removeHandler;
    polyline.on('remove', removeHandler);
  }
  (function addMeasureTool(){
    let active=false, start=null, guide=null;
    const group = L.layerGroup().addTo(map);
    const measureBtn = document.getElementById('measureBtn');
    const clearBtn   = document.getElementById('clearBtn');

    let prevInteractions = null;
    function disableMapInteractions(){
      if(prevInteractions) return;
      prevInteractions = {
        dragging: map.dragging?.enabled?.() ?? false,
        scrollWheelZoom: map.scrollWheelZoom?.enabled?.() ?? false,
        doubleClickZoom: map.doubleClickZoom?.enabled?.() ?? false,
        boxZoom: map.boxZoom?.enabled?.() ?? false,
        touchZoom: map.touchZoom?.enabled?.() ?? false,
        keyboard: map.keyboard?.enabled?.() ?? false
      };
      map.dragging?.disable?.();
      map.scrollWheelZoom?.disable?.();
      map.doubleClickZoom?.disable?.();
      map.boxZoom?.disable?.();
      map.touchZoom?.disable?.();
      map.keyboard?.disable?.();
    }
    function restoreMapInteractions(){
      if(!prevInteractions) return;
      if(prevInteractions.dragging) map.dragging?.enable?.();
      if(prevInteractions.scrollWheelZoom) map.scrollWheelZoom?.enable?.();
      if(prevInteractions.doubleClickZoom) map.doubleClickZoom?.enable?.();
      if(prevInteractions.boxZoom) map.boxZoom?.enable?.();
      if(prevInteractions.touchZoom) map.touchZoom?.enable?.();
      if(prevInteractions.keyboard) map.keyboard?.enable?.();
      prevInteractions = null;
    }
    function syncOverlayInteractivity(){
      const disable = measurementActive;
      setOverlayPointerPassthrough('measure', disable);
      if(disable) disableMapInteractions(); else restoreMapInteractions();
    }

    function handlePoint(latlng){
      if(!active) return;
      if(!start){
        start = latlng;
        guide = L.polyline([start,start], { color:'#111827', weight:2, dashArray:'5,4' }).addTo(map);
      } else {
        const end = latlng;
        L.polyline([start,end], { color:'#111827', weight:3 }).addTo(group);
        const nmLength = computeLineLengthNm(start, end);
        const mid = midpointLatLng(start, end);
        L.marker(mid, {
          icon: L.divIcon({ className:'twic-badge', html: formatNauticalMiles(nmLength), iconSize: null }),
          interactive: false
        }).addTo(group);
        cancel();
      }
    }

    measurementHandlePoint = handlePoint;

    function begin(){
      active=true; start=null; measurementActive = true; syncOverlayInteractivity();
      resetManeuverDraft();
      updateMapCursor();
      mapEl.focus();
    }
    function cancel(){
      active=false; start=null; measurementActive = false; syncOverlayInteractivity();
      if(guide){ map.removeLayer(guide); guide=null; }
      updateMapCursor();
      measureBtn?.classList.remove('active');
    }
    function clearAll(){ group.clearLayers(); cancel(); }

    map.on('click', e => { handlePoint(e.latlng); });
    map.on('mousemove', e => { if(active && guide && start) guide.setLatLngs([start, e.latlng]); });
    document.addEventListener('keydown', e => { if(e.key === 'Escape') cancel(); });

    measurementCancel = cancel;

    measureBtn.onclick = () => { measureBtn.classList.add('active'); begin(); };
    clearBtn.onclick   = () => { measureBtn.classList.remove('active'); clearAll(); };
  })();

  /* ===== Overlay: text + simplified NATO symbols (frame/fill only) ===== */
  const overlayLayer = L.layerGroup().addTo(map);
  let selected = null;
  let maneuverStart = null, maneuverGuide = null, maneuverGuideTooltip = null;

  const overlayIndex = new Map();
  const pendingRangeAttachments = new Map();

  function generateOverlayId(kind='overlay'){
    if(window.crypto?.randomUUID) return crypto.randomUUID();
    return `${kind}-${Math.random().toString(36).slice(2,10)}${Date.now().toString(36)}`;
  }

  function ensureMarkerAttachmentHandlers(marker){
    if(marker._rangeDragHandler) return;
    marker._rangeDragHandler = () => {
      const latlng = marker.getLatLng();
      marker._attachedRanges?.forEach(range => range.setLatLng(latlng));
    };
    marker.on('drag', marker._rangeDragHandler);
  }

  function attachRangeToMarker(range, marker){
    if(!marker) return;
    const markerId = marker.options?.meta?.id;
    if(!markerId) return;
    if(!marker._attachedRanges) marker._attachedRanges = new Set();
    marker._attachedRanges.add(range);
    range._attachedTo = marker;
    range.options.meta.attachedTo = markerId;
    range.setLatLng(marker.getLatLng());
    ensureMarkerAttachmentHandlers(marker);
  }

  function queueRangeForMarker(range, markerId){
    if(!markerId) return;
    const list = pendingRangeAttachments.get(markerId) || [];
    list.push(range);
    pendingRangeAttachments.set(markerId, list);
  }

  function registerMarker(layer){
    if(!layer.options.meta) layer.options.meta = { kind:'nato' };
    if(!layer.options.meta.id) layer.options.meta.id = generateOverlayId('nato');
    const id = layer.options.meta.id;
    overlayIndex.set(id, layer);
    const queued = pendingRangeAttachments.get(id);
    if(queued){
      queued.forEach(range => attachRangeToMarker(range, layer));
      pendingRangeAttachments.delete(id);
    }
  }

  function detachRange(range){
    const anchorId = range.options?.meta?.attachedTo || null;
    if(anchorId && !range._attachedTo){
      const pending = pendingRangeAttachments.get(anchorId);
      if(pending){
        const next = pending.filter(item => item !== range);
        if(next.length) pendingRangeAttachments.set(anchorId, next);
        else pendingRangeAttachments.delete(anchorId);
      }
    }
    const marker = range._attachedTo;
    if(marker?._attachedRanges){
      marker._attachedRanges.delete(range);
      if(marker._attachedRanges.size === 0){
        if(marker._rangeDragHandler){
          marker.off('drag', marker._rangeDragHandler);
          marker._rangeDragHandler = null;
        }
        delete marker._attachedRanges;
      }
    }
    range._attachedTo = null;
    if(range.options?.meta) range.options.meta.attachedTo = null;
  }

  function unregisterMarker(layer){
    const id = layer.options?.meta?.id;
    if(!id) return;
    overlayIndex.delete(id);
    if(layer._attachedRanges){
      [...layer._attachedRanges].forEach(range => {
        overlayLayer.removeLayer(range);
      });
    }
  }

  overlayLayer.on('layeradd', e => {
    const layer = e.layer;
    const kind = layer?.options?.meta?.kind;
    if(kind === 'nato'){
      registerMarker(layer);
    } else if(kind === 'weaponRange'){
      const anchorId = layer.options.meta.attachedTo;
      if(anchorId){
        const marker = overlayIndex.get(anchorId);
        if(marker) attachRangeToMarker(layer, marker);
        else queueRangeForMarker(layer, anchorId);
      }
    }
  });

  overlayLayer.on('layerremove', e => {
    const layer = e.layer;
    const kind = layer?.options?.meta?.kind;
    if(kind === 'nato'){
      unregisterMarker(layer);
    } else if(kind === 'weaponRange'){
      detachRange(layer);
    }
  });

  function capturePathStyle(layer){
    return {
      color: layer.options.color,
      weight: layer.options.weight,
      dashArray: layer.options.dashArray,
      fillColor: layer.options.fillColor,
      fillOpacity: layer.options.fillOpacity
    };
  }

  function clearSelection(){
    if(!selected) return;
    if(selected._icon){
      selected._icon.style.outline='';
    } else if(selected.setStyle && selected.options._selectedBackup){
      selected.setStyle(selected.options._selectedBackup);
      delete selected.options._selectedBackup;
    }
    selected=null;
  }
  function selectLayer(l){
    if(measurementActive) return;
    clearSelection();
    selected=l;
    if(l._icon){
      l._icon.style.outline='2px solid #111827';
    } else if(l.setStyle){
      l.options._selectedBackup = capturePathStyle(l);
      const highlight = { color:'#111827', weight:(l.options.weight || 2)+1 };
      if(!l.options.fillColor) highlight.dashArray = '4,3';
      l.setStyle(highlight);
    }
  }
  function attachSelectablePath(layer){
    layer.on('click', e => {
      if(measurementActive){
        measurementHandlePoint?.(e.latlng);
        e.originalEvent?.stopPropagation?.();
        return;
      }
      selectLayer(layer);
      e.originalEvent.stopPropagation();
    });
  }
  function resetManeuverDraft(){
    maneuverStart = null;
    if(maneuverGuide){ map.removeLayer(maneuverGuide); maneuverGuide=null; }
    if(maneuverGuideTooltip){ map.removeLayer(maneuverGuideTooltip); maneuverGuideTooltip=null; }
  }

  toolMode = document.getElementById('toolMode');
  const textOpts = document.getElementById('textOpts');
  const natoOpts = document.getElementById('natoOpts');
  const weaponOpts = document.getElementById('weaponOpts');
  const maneuverOpts = document.getElementById('maneuverOpts');

  const weaponRadius = document.getElementById('weaponRadius');
  const weaponStroke = document.getElementById('weaponStroke');
  const weaponFill = document.getElementById('weaponFill');
  const weaponOpacity = document.getElementById('weaponOpacity');
  const maneuverColor = document.getElementById('maneuverColor');
  const maneuverWidth = document.getElementById('maneuverWidth');
  const maneuverDash = document.getElementById('maneuverDash');
  const btnPlaceText = document.getElementById('btnPlaceText');
  const btnPlaceNato = document.getElementById('btnPlaceNato');
  const btnPlaceRange = document.getElementById('btnPlaceRange');
  const btnPlaceManeuver = document.getElementById('btnPlaceManeuver');

  function beginSinglePlacement(mode){
    if(!mode) return;
    measurementCancel?.();
    singlePlacementActive = true;
    singlePlacementMode = mode;
    if(toolMode.value !== mode){
      toolMode.value = mode;
    }
    syncToolPanels();
    updateMapCursor();
    mapEl.focus();
  }

  function finishSinglePlacement(){
    singlePlacementActive = false;
    singlePlacementMode = null;
    if(toolMode.value !== 'select'){
      toolMode.value = 'select';
    }
    syncToolPanels();
    updateMapCursor();
  }

  function maybeCompleteSinglePlacement(mode){
    if(!singlePlacementActive) return;
    if(singlePlacementMode && singlePlacementMode !== mode) return;
    finishSinglePlacement();
  }

  function cancelSinglePlacement(){
    if(!singlePlacementActive) return;
    finishSinglePlacement();
  }

  btnPlaceText?.addEventListener('click', () => beginSinglePlacement('text'));
  btnPlaceNato?.addEventListener('click', () => beginSinglePlacement('nato'));
  btnPlaceRange?.addEventListener('click', () => beginSinglePlacement('weaponRange'));
  btnPlaceManeuver?.addEventListener('click', () => beginSinglePlacement('maneuver'));

  function syncToolPanels(){
    const mode = toolMode.value;
    textOpts.style.display = (mode === 'text') ? '' : 'none';
    natoOpts.style.display = (mode === 'nato') ? '' : 'none';
    weaponOpts.style.display = (mode === 'weaponRange') ? '' : 'none';
    maneuverOpts.style.display = (mode === 'maneuver') ? '' : 'none';
    const maneuverActive = (mode === 'maneuver');
    setOverlayPointerPassthrough('maneuver', maneuverActive);
    setOverlayPointerPassthrough('toolMode', mode !== 'select');
    if(!maneuverActive) resetManeuverDraft();
    updateMapCursor();
  }
  toolMode.addEventListener('change', () => {
    singlePlacementActive = false;
    singlePlacementMode = null;
    syncToolPanels();
  });
  syncToolPanels();

  /* Text boxes */
  function makeTextDivIcon(t, s=12, c='#111', bg='#fff', bo='#e5e7eb'){
    const html = `<div class="twic-text" style="font-size:${s}px;color:${c};background:${bg};border-color:${bo};">${t.replace(/</g,'&lt;')}</div>`;
    return L.divIcon({ className:'', html, iconSize:null });
  }
  function addTextAt(p){
    const t = txtText.value || 'Label';
    const s = +txtSize.value || 12;
    const c = txtColor.value;
    const bg= txtBg.value;
    const b = txtBorder.value;
    const m = L.marker(p, { icon: makeTextDivIcon(t,s,c,bg,b), draggable:true }).addTo(overlayLayer);
    m.on('click', e => {
      if(measurementActive){
        measurementHandlePoint?.(e.latlng);
        e.originalEvent?.stopPropagation?.();
        return;
      }
      selectLayer(m); e.originalEvent.stopPropagation();
    });
    m.on('dragstart', clearSelection);
    maybeCompleteSinglePlacement('text');
  }

  /* NATO symbol mapping (Air/Surface/Ground/Subsurface × Friendly/Hostile/Neutral) */
  const SIDC_MAP = {
    // Ground (unit – Infantry, Present)
    G: { base:"SUG-UCI----D", F:"SFG-UCI----D", H:"SHG-UCI----D", N:"SNG-UCI----D" },
    // Air (track – generic aircraft)
    A: { base:"SUAPMFQA----", F:"SFAPMFQA----", H:"SHAPMFQA----", N:"SNAPMFQA----" },
    // Surface (sea surface track – generic ship)
    S: { base:"SUSPMFQA----", F:"SFSPMFQA----", H:"SHSPMFQA----", N:"SNSPMFQA----" },
    // Subsurface (submarine track)
    U: { base:"SUUPMFQA----", F:"SFUPMFQA----", H:"SHUPMFQA----", N:"SNUPMFQA----" }
  };
  function getSidc(domain, aff){
    const cat = SIDC_MAP[domain];
    if(!cat) return null;
    if(cat[aff]) return cat[aff];
    const b = cat.base;
    return aff + b.slice(1); // swap affiliation letter
  }
  function makeNatoIcon(domain, aff, size=36){
    try{
      const sidc = getSidc(domain, aff);
      if(!sidc) throw new Error(`Unknown domain ${domain}`);
      if(!window.ms || !ms.Symbol) throw new Error('milsymbol not loaded');
      // Frame/background only (no center pictogram)
      const sym = new ms.Symbol(sidc, {
        size,
        icon: false,
        fill: true,
        frame: true,
        outlineWidth: size*0.06
      });
      const url = sym.asCanvas().toDataURL();
      return L.icon({ iconUrl:url, iconSize:[size,size] });
    }catch(err){
      console.error('NATO render failed:', err);
      return L.divIcon({
        className:'',
        html:`<div style="width:${size/3}px;height:${size/3}px;border-radius:50%;background:#111"></div>`,
        iconSize:[size/3,size/3]
      });
    }
  }
  function addNatoAt(p){
    const d = natoDomain.value;   // A/S/G/U
    const a = natoAff.value;      // F/H/N
    const s = +natoSize.value || 36;
    const id = generateOverlayId('nato');
    const m = L.marker(p, { icon: makeNatoIcon(d,a,s), draggable:true });
    m.options.meta = { kind:'nato', domain:d, aff:a, size:s, id };
    m.addTo(overlayLayer);
    m.on('click', e => {
      if(measurementActive){
        measurementHandlePoint?.(e.latlng);
        e.originalEvent?.stopPropagation?.();
        return;
      }
      const mode = toolMode?.value;
      if(mode === 'maneuver'){
        handleManeuverClick(m.getLatLng());
        e.originalEvent?.stopPropagation?.();
        return;
      }
      if(mode === 'weaponRange') return;
      selectLayer(m); e.originalEvent.stopPropagation();
    });
    m.on('dragstart', clearSelection);
    maybeCompleteSinglePlacement('nato');
  }

  function dashPatternFromValue(val){
    switch(val){
      case 'dashed': return '10,6';
      case 'dotted': return '3,6';
      default: return '';
    }
  }
  function addWeaponRangeAt(p){
    const radiusNm = Math.max(0, +weaponRadius.value || 0);
    if(!radiusNm) return;
    const stroke = weaponStroke.value || '#ef4444';
    const fill = weaponFill.value || stroke;
    const fillOpacity = Math.min(1, Math.max(0, parseFloat(weaponOpacity.value) || 0));
    const anchorMarker = (selected && selected.options?.meta?.kind === 'nato') ? selected : null;
    const center = anchorMarker ? anchorMarker.getLatLng() : p;
    const circle = L.circle(center, {
      radius: radiusNm / UNITS_PER_PIXEL,
      color: stroke,
      weight: 2,
      fillColor: fill,
      fillOpacity
    });
    const attachedTo = anchorMarker?.options?.meta?.id || null;
    circle.options.meta = { kind:'weaponRange', radiusNm, color: stroke, fillColor: fill, fillOpacity, attachedTo };
    circle.addTo(overlayLayer);
    attachSelectablePath(circle);
    if(anchorMarker) attachRangeToMarker(circle, anchorMarker);
    maybeCompleteSinglePlacement('weaponRange');
  }
  function handleManeuverClick(p){
    const color = maneuverColor.value || '#2563eb';
    const weight = +maneuverWidth.value || 3;
    const dashArray = dashPatternFromValue(maneuverDash.value);
    if(!maneuverStart){
      maneuverStart = p;
      maneuverGuide = L.polyline([p,p], { color, weight, dashArray, opacity:0.6, interactive:false }).addTo(map);
      maneuverGuideTooltip = L.tooltip({
        permanent: true,
        direction: 'center',
        className: 'twic-badge twic-badge--maneuver',
        offset: [0, 0],
        opacity: 1
      }).setContent(formatNauticalMiles(0)).setLatLng(p).addTo(map);
    } else {
      const latlngs = [maneuverStart, p];
      const poly = L.polyline(latlngs, { color, weight, dashArray }).addTo(overlayLayer);
      poly.options.meta = { kind:'maneuver', color, weight, dashArray };
      attachSelectablePath(poly);
      attachManeuverLengthLabel(poly);
      resetManeuverDraft();
      maybeCompleteSinglePlacement('maneuver');
    }
  }
  map.on('mousemove', e => {
    if(maneuverStart && maneuverGuide){
      maneuverGuide.setLatLngs([maneuverStart, e.latlng]);
      if(maneuverGuideTooltip){
        const midpoint = midpointLatLng(maneuverStart, e.latlng);
        if(midpoint){
          const lengthNm = computeLineLengthNm(maneuverStart, e.latlng);
          maneuverGuideTooltip.setLatLng(midpoint).setContent(formatNauticalMiles(lengthNm));
        }
      }
    }
  });
  document.addEventListener('keydown', e => {
    if(e.key !== 'Escape') return;
    if(toolMode.value === 'maneuver') resetManeuverDraft();
    cancelSinglePlacement();
  });

  map.on('click', e => {
    if (measurementActive) return;
    if (toolMode.value === 'text') addTextAt(e.latlng);
    else if (toolMode.value === 'nato') addNatoAt(e.latlng);
    else if (toolMode.value === 'weaponRange') addWeaponRangeAt(e.latlng);
    else if (toolMode.value === 'maneuver') handleManeuverClick(e.latlng);
    else clearSelection();
  });

  document.getElementById('btnDelete').onclick = () => { if (selected) { overlayLayer.removeLayer(selected); selected=null; } };
  document.getElementById('btnOverlayClear').onclick = () => { overlayLayer.clearLayers(); selected=null; resetManeuverDraft(); };
  mapEl.addEventListener('keydown', e => {
    if ((e.key === 'Delete' || e.key === 'Backspace') && selected) {
      overlayLayer.removeLayer(selected); selected=null;
    }
  });

  /* ===== Shared overlays: share-link (URL hash) + repo file fallback ===== */


  function overlaysToFeatureCollection() {
    const feats = [];
    overlayLayer.eachLayer(layer => {
      const metaKind = layer.options?.meta?.kind;

      if (metaKind === 'maneuver') {
        const latlngs = layer.getLatLngs?.() || [];
        if (!latlngs.length) return;
        const coords = latlngs.map(ll => [ll.lng, ll.lat]);
        feats.push({
          type:'Feature',
          geometry:{ type:'LineString', coordinates: coords },
          properties:{
            kind:'maneuver',
            color: layer.options.meta.color,
            weight: layer.options.meta.weight,
            dashArray: layer.options.meta.dashArray || ''
          }
        });
        return;
      }

      if (metaKind === 'weaponRange') {
        if (!layer.getLatLng) return;
        const center = layer.getLatLng();
        feats.push({
          type:'Feature',
          geometry:{ type:'Point', coordinates:[center.lng, center.lat] },
          properties:{
            kind:'weaponRange',
            radiusNm: layer.options.meta.radiusNm,
            color: layer.options.meta.color,
            fillColor: layer.options.meta.fillColor,
            fillOpacity: layer.options.meta.fillOpacity,
            attachedTo: layer.options.meta.attachedTo || null
          }
        });
        return;
      }

      if (!layer.getLatLng) return;
      const p = layer.getLatLng();
      let props = { kind:'unknown' };

      if (layer.options.icon && typeof layer.options.icon.options.html === 'string') {
        const div = document.createElement('div');
        div.innerHTML = layer.options.icon.options.html;
        const el = div.firstChild;
        const style = el.getAttribute('style') || '';
        props = {
          kind:  'text',
          text:  el.textContent || '',
          size:  +(style.match(/font-size:(\d+)px/)?.[1] || 12),
          color: (style.match(/color:\s*([^;]+)/)?.[1] || '#111'),
          bg:    (style.match(/background:\s*([^;]+)/)?.[1] || '#fff'),
          border:(style.match(/border-color:\s*([^;]+)/)?.[1] || '#e5e7eb')
        };
      }

      if (layer.options.meta?.kind === 'nato') {
        props = {
          kind:   'nato',
          domain: layer.options.meta.domain, // A/S/G/U
          aff:    layer.options.meta.aff,    // F/H/N
          size:   layer.options.meta.size,
          id:     layer.options.meta.id
        };
      }

      feats.push({
        type:'Feature',
        geometry:{ type:'Point', coordinates:[p.lng, p.lat] },
        properties: props
      });
    });
    return { type:'FeatureCollection', features:feats };
  }

  function featureCollectionToOverlays(gj) {
    overlayLayer.clearLayers(); selected = null; resetManeuverDraft();
    (gj.features || []).forEach(f => {
      const k = f.properties?.kind;

      if (k === 'maneuver') {
        if (f.geometry?.type !== 'LineString') return;
        const coords = Array.isArray(f.geometry.coordinates) ? f.geometry.coordinates : [];
        const latlngs = coords.map(pt => L.latLng(pt[1], pt[0])).filter(ll => Number.isFinite(ll.lat) && Number.isFinite(ll.lng));
        if (latlngs.length < 2) return;
        const { color='#2563eb', weight=3, dashArray='' } = f.properties || {};
        const poly = L.polyline(latlngs, { color, weight, dashArray }).addTo(overlayLayer);
        poly.options.meta = { kind:'maneuver', color, weight, dashArray };
        attachSelectablePath(poly);
        attachManeuverLengthLabel(poly);
        return;
      }

      if (k === 'weaponRange') {
        if (f.geometry?.type !== 'Point') return;
        const [cx,cy] = f.geometry.coordinates;
        const center = L.latLng(cy,cx);
        const { radiusNm=0, color='#ef4444', fillColor='#ef4444', fillOpacity=0.15, attachedTo=null } = f.properties || {};
        if (!radiusNm) return;
        const normalizedFill = Math.min(1, Math.max(0, +fillOpacity || 0));
        const circle = L.circle(center, {
          radius: radiusNm / UNITS_PER_PIXEL,
          color,
          weight: 2,
          fillColor,
          fillOpacity: normalizedFill
        });
        circle.options.meta = { kind:'weaponRange', radiusNm, color, fillColor, fillOpacity: normalizedFill, attachedTo };
        circle.addTo(overlayLayer);
        attachSelectablePath(circle);
        return;
      }

      if (f.geometry?.type !== 'Point') return;
      const [x,y] = f.geometry.coordinates;
      const p = L.latLng(y,x);

      if (k === 'text') {
        const { text='', size=12, color='#111', bg='#fff', border='#e5e7eb' } = f.properties || {};
        const mk = L.marker(p, { icon: makeTextDivIcon(text,size,color,bg,border), draggable:true }).addTo(overlayLayer);
        mk.on('click', e => {
          if(measurementActive){
            measurementHandlePoint?.(e.latlng);
            e.originalEvent?.stopPropagation?.();
            return;
          }
          selectLayer(mk); e.originalEvent.stopPropagation();
        });
        mk.on('dragstart', clearSelection);
        return;
      }
      if (k === 'nato') {
        const { domain='G', aff='F', size=36, id=null } = f.properties || {};
        const mk = L.marker(p, { icon: makeNatoIcon(domain,aff,size), draggable:true });
        mk.options.meta = { kind:'nato', domain, aff, size, id: id || generateOverlayId('nato') };
        mk.addTo(overlayLayer);
        mk.on('click', e => {
          if(measurementActive){
            measurementHandlePoint?.(e.latlng);
            e.originalEvent?.stopPropagation?.();
            return;
          }
          const mode = toolMode?.value;
          if(mode === 'maneuver'){
            handleManeuverClick(mk.getLatLng());
            e.originalEvent?.stopPropagation?.();
            return;
          }
          if(mode === 'weaponRange') return;
          selectLayer(mk); e.originalEvent.stopPropagation();
        });
        mk.on('dragstart', clearSelection);
        return;
      }
    });
  }

  // --- Share link (hash) helpers: #s=<compressed>
  function setHashFromOverlays() {
    const fc = overlaysToFeatureCollection();
    const json = JSON.stringify(fc);
    const packed = LZString.compressToEncodedURIComponent(json);
    location.hash = 's=' + packed;
  }
  function tryLoadFromHash() {
    const h = new URL(location.href).hash.slice(1);
    if (!h.startsWith('s=')) return false;
    try {
      const packed = h.substring(2);
      const json = LZString.decompressFromEncodedURIComponent(packed);
      if (!json) return false;
      const fc = JSON.parse(json);
      featureCollectionToOverlays(fc);
      return true;
    } catch { return false; }
  }

  // --- Repo file fallback: overlays.geojson at repo root
  async function tryLoadFromRepoFile() {
    try {
      const res = await fetch('./overlays.geojson', { cache:'no-cache' });
      if (!res.ok) return false;
      const gj = await res.json();
      featureCollectionToOverlays(gj);
      return true;
    } catch { return false; }
  }

  // Bootstrap: prefer URL hash state; else fall back to repo file
  (async function bootstrapOverlays(){
    const loadedFromHash = tryLoadFromHash();
    if (!loadedFromHash) await tryLoadFromRepoFile();
  })();

  // Wire the Share button
  document.getElementById('btnShare').addEventListener('click', () => {
    setHashFromOverlays();
    navigator.clipboard?.writeText(location.href).catch(()=>{});
    alert('Shareable link updated in the address bar (copied to clipboard if permitted).');
  });
  </script>
<script>

const SUPABASE_URL = 'https://pzezmofpgtzofpveucmz.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InB6ZXptb2ZwZ3R6b2ZwdmV1Y216Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjAzNTc5NDYsImV4cCI6MjA3NTkzMzk0Nn0.DZLlxcrYgW5iTIpG-YAeRCwYGXCghN_aNWBigjnx3cI';
const ROOM_ID = 'public';  // use any string; all visitors share this document

const sb = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
</script>

let _saving = false;

async function loadFromSupabase() {
  const { data, error } = await sb
    .from('overlays')
    .select('data, updated_at')
    .eq('id', ROOM_ID)
    .single();

  if (error) { console.warn('Supabase load error:', error.message); return false; }
  if (data?.data) {
    featureCollectionToOverlays(data.data);
    return true;
  }
  return false;
}

const saveOverlays = debounce(async () => {
  const fc = overlaysToFeatureCollection();
  _saving = true;
  const { error } = await sb
    .from('overlays')
    .upsert({ id: ROOM_ID, data: fc })
    .eq('id', ROOM_ID);
  if (error) console.warn('Supabase save error:', error.message);

  setTimeout(() => { _saving = false; }, 300);
}, 350);

const channel = sb
  .channel('overlays-listen')
  .on(
    'postgres_changes',
    { event: '*', schema: 'public', table: 'overlays', filter: `id=eq.${ROOM_ID}` },
    (payload) => {
      if (_saving) return; // ignore our own save
      const next = (payload.new && payload.new.data) || null;
      if (!next) return;
      featureCollectionToOverlays(next);
    }
  )
  .subscribe();

/* Hook saves to your existing UI events */
function hookOverlaySaves() {
  // When a layer is added/removed
  overlayLayer.on('layeradd', saveOverlays);
  overlayLayer.on('layerremove', saveOverlays);


  overlayLayer.eachLayer(l => { if (l.dragging) l.on('dragend', saveOverlays); });
  overlayLayer.on('layeradd', l => { if (l.layer?.dragging) l.layer.on('dragend', saveOverlays); });

function debounce(fn, wait=300){
  let t; return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn(...args), wait); };
}

(async function bootstrapCollab(){
  const loadedFromHash = (function(){
    try { return tryLoadFromHash(); } catch { return false; }
  })();
  if (!loadedFromHash) {
    const loadedFromRepo = await (async () => { try { return await tryLoadFromRepoFile(); } catch { return false; } })();
    if (!loadedFromRepo) {
      await loadFromSupabase(); // finally, shared doc
    }
  }
  hookOverlaySaves();
})();
</script>
</body>
</html>
